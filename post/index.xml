<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Headstone lamp - It&#39;s always has been</title>
    <link>https://solairerove.github.io/post/</link>
    <description>Recent content in Posts on Headstone lamp - It&#39;s always has been</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 22 Oct 2021 14:30:19 +0300</lastBuildDate><atom:link href="https://solairerove.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Find the Closest Value in Bst</title>
      <link>https://solairerove.github.io/post/find-the-closest-value-in-bst/</link>
      <pubDate>Fri, 22 Oct 2021 14:30:19 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/find-the-closest-value-in-bst/</guid>
      <description>14 / \ 7 21 /\ /\ 3 8 15 25  Input: 16
Output: 15
find the closest value
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  open class BST(var value: Int) { var left: BST? = null var right: BST? = null } // O(log(n)) time | O(1) space // worst O(n) time | O(1) space fun findTheClosestValueInBst(tree: BST?</description>
    </item>
    
    <item>
      <title>Number of Islands</title>
      <link>https://solairerove.github.io/post/number-of-islands/</link>
      <pubDate>Thu, 29 Jul 2021 16:28:46 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/number-of-islands/</guid>
      <description>Input:
1 2 3 4  [1 1 0 0 0] [1 1 0 0 0] [0 0 1 0 0] [0 0 0 1 1]   Output: 3
number of islands leetcode
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // O(m * n) time | O(m * n) space fun numIslandsDFS(grid: List&amp;lt;MutableList&amp;lt;String&amp;gt;&amp;gt;): Int { if (grid.</description>
    </item>
    
    <item>
      <title>Largest Range</title>
      <link>https://solairerove.github.io/post/largest-range/</link>
      <pubDate>Fri, 18 Jun 2021 15:18:35 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/largest-range/</guid>
      <description>Input: [1, 9, 10, 12, 14, 16, 11, 17, 13, 3]
Output: [9, 14]
largest range
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // O(n) time | O(n) space fun largestRange(arr: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; { var range = listOf(arr[0], arr[0]) var length = 0 val nums = mutableMapOf&amp;lt;Int, Boolean&amp;gt;() arr.</description>
    </item>
    
    <item>
      <title>Min Rewards</title>
      <link>https://solairerove.github.io/post/min-rewards/</link>
      <pubDate>Thu, 17 Jun 2021 19:07:12 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/min-rewards/</guid>
      <description>Input: [9, 2, 3, 1, 8, 4, 7]
Output: 11
min rewards
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // O(n) time | O(n) space fun minRewards(scores: List&amp;lt;Int&amp;gt;): Int { val n = scores.size val rewards = MutableList(n) { 1 } for (i in 1 until n) { if (scores[i] &amp;gt; scores[i - 1]) { rewards[i] = rewards[i - 1] + 1 } } for (i in n - 2 downTo 0) { if (scores[i] &amp;gt; scores[i + 1]) { rewards[i] = max(rewards[i], rewards[i + 1] + 1) } } return rewards.</description>
    </item>
    
    <item>
      <title>Shift Linked List</title>
      <link>https://solairerove.github.io/post/shift-linked-list/</link>
      <pubDate>Wed, 16 Jun 2021 14:45:29 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/shift-linked-list/</guid>
      <description>Input: [1, 2, 3, 4, 5], 2
Output: [4, 5, 1, 2, 3]
shift linked list
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  open class ListNode(var value: Int) { var next: ListNode? = null } // O(n) time | O(1) space fun shiftLinkedList(head: ListNode, k: Int): ListNode { var length = 1 var tail = head while (tail.</description>
    </item>
    
    <item>
      <title>Linked List</title>
      <link>https://solairerove.github.io/post/linked-list/</link>
      <pubDate>Tue, 15 Jun 2021 21:24:36 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/linked-list/</guid>
      <description>linked list
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  class Node(val value: Int) { var next: Node?</description>
    </item>
    
    <item>
      <title>Staircase Traverse</title>
      <link>https://solairerove.github.io/post/staircase-traverse/</link>
      <pubDate>Mon, 14 Jun 2021 21:34:18 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/staircase-traverse/</guid>
      <description>Input: 4 3
Output: 7
staircase traverse
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // O(n) time | O(n) space fun staircaseTraverse(height: Int, maxSteps: Int): Int { var number = 0 val ways = mutableListOf(1) for (curr in 1 until height + 1) { val low = curr - maxSteps - 1 val high = curr - 1 if (low &amp;gt;= 0) number -= ways[low] number += ways[high] ways.</description>
    </item>
    
    <item>
      <title>Sum of Linked Lists</title>
      <link>https://solairerove.github.io/post/sum-of-linked-lists/</link>
      <pubDate>Fri, 11 Jun 2021 16:53:53 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/sum-of-linked-lists/</guid>
      <description>Input: [1 2 3 4 5 6] [7 8 9 10] Output: [8 0 3 5 6 6]
sum of linked lists
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class ListNode(var value: Int) { var next: ListNode? = null } // O(max(n + m)) time | O(max(n + m)) space fun sumOfLinkedLists(headFirst: ListNode, headSecond: ListNode): ListNode { val newHead = ListNode(0) var curr = newHead var carry = 0 var nodeOne: ListNode?</description>
    </item>
    
    <item>
      <title>Merge Linked Lists</title>
      <link>https://solairerove.github.io/post/merge-linked-lists/</link>
      <pubDate>Thu, 10 Jun 2021 18:08:37 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/merge-linked-lists/</guid>
      <description>Input: [1 2 3 4 5 6] [7 8 9 10] Output: [1 2 3 4 5 6 7 8 9 10]
merge linked lists
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class ListNode(var value: Int) { var next: ListNode? = null } // O(n + m) time | O(1) space fun mergeLinkedLists(headFirst: ListNode, headSecond: ListNode): ListNode { var i: ListNode?</description>
    </item>
    
    <item>
      <title>Find Loop</title>
      <link>https://solairerove.github.io/post/find-loop/</link>
      <pubDate>Wed, 09 Jun 2021 17:31:41 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/find-loop/</guid>
      <description>Input:
1 2 3  1 -&amp;gt; 2 -&amp;gt; 3 | | 5 &amp;lt;- 4   Output: 2
find loop
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class ListNode(var value: Int) { var next: ListNode? = null } // O(n) time | O(1) space fun findLoop(head: ListNode?): ListNode? { var first = head?.next var second = first?</description>
    </item>
    
    <item>
      <title>Balanced Brackets</title>
      <link>https://solairerove.github.io/post/balanced-brackets/</link>
      <pubDate>Tue, 08 Jun 2021 14:49:38 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/balanced-brackets/</guid>
      <description>Input: &amp;ldquo;[()]{}{()()}&amp;rdquo;
Output: true
balanced brackets
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // O(n) time | O(n) space fun balancedBrackets(s: String): Boolean { val stack = Stack&amp;lt;Char&amp;gt;() for (i in s.indices) { if (&amp;#39;(&amp;#39; == s[i]) stack.push(&amp;#39;(&amp;#39;) if (&amp;#39;[&amp;#39; == s[i]) stack.push(&amp;#39;[&amp;#39;) if (&amp;#39;{&amp;#39; == s[i]) stack.push(&amp;#39;{&amp;#39;) if (&amp;#39;)&amp;#39; == s[i]) { if (stack.</description>
    </item>
    
    <item>
      <title>Powerset</title>
      <link>https://solairerove.github.io/post/powerset/</link>
      <pubDate>Mon, 07 Jun 2021 19:42:59 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/powerset/</guid>
      <description>Input: [1, 2]
Output: [[], [1], [2], [1, 2]]
powerset
1 2 3 4 5 6 7 8 9 10 11 12  // O(n*2ˆn) time | O(n*2ˆn) space fun powerset(arr: List&amp;lt;Int&amp;gt;): List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt; { val sets = mutableListOf(listOf&amp;lt;Int&amp;gt;()) for (el in arr) { for (i in 0 until sets.size) { val curr = sets[i].toMutableList() curr.add(el) sets.add(curr) } } return sets }   </description>
    </item>
    
    <item>
      <title>Permutations</title>
      <link>https://solairerove.github.io/post/permutations/</link>
      <pubDate>Fri, 04 Jun 2021 18:46:38 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/permutations/</guid>
      <description>Input: [1, 2]
Output: [[1, 2], [2, 1]]
permutations
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // O(n*n!) time | O(n*n!) space fun permutations(arr: List&amp;lt;Int&amp;gt;): List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt; { val perms = mutableListOf&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt;() permutations(arr.toMutableList(), 0, perms) return perms } fun permutations(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, perms: MutableList&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt;) { val n = arr.size if (i == n - 1) { perms.</description>
    </item>
    
    <item>
      <title>Remove K Node From End</title>
      <link>https://solairerove.github.io/post/remove-k-node-from-end/</link>
      <pubDate>Thu, 03 Jun 2021 20:08:24 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/remove-k-node-from-end/</guid>
      <description>Input: [1, 1, 1, 2, 2, 3], 2
Output: [1, 1, 1, 2, 3]
remove k node from end
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class ListNode(var value: Int) { var next: ListNode? = null } // O(n) time | O(1) space fun removeKNodeFromEnd(head: ListNode, k: Int) { var cnt = 1 var first = head var second: ListNode?</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Linked List</title>
      <link>https://solairerove.github.io/post/remove-duplicates-from-linked-list/</link>
      <pubDate>Wed, 02 Jun 2021 20:04:39 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/remove-duplicates-from-linked-list/</guid>
      <description>Input: [1, 1, 1, 2, 2, 3]
Output: [1, 2, 3]
remove duplicates from linked list
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class ListNode(var value: Int) { var next: ListNode? = null } // O(n) time | O(1) space fun removeDuplicatesFromLinkedList(linkedList: ListNode): ListNode { var curr: ListNode? = linkedList while (curr != null) { var next = curr.</description>
    </item>
    
    <item>
      <title>To Binary String</title>
      <link>https://solairerove.github.io/post/to-binary-string/</link>
      <pubDate>Tue, 01 Jun 2021 21:25:18 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/to-binary-string/</guid>
      <description>Input: &amp;ldquo;10&amp;rdquo;
Output: &amp;ldquo;1010&amp;rdquo;
to binary string
1 2 3 4 5 6 7 8 9 10 11  // O(n) time | O(n) space fun toBinaryString(n: Int): String { val stringBuilder = StringBuilder() var idx = n while (idx &amp;gt; 0) { stringBuilder.insert(0, idx % 2) idx /= 2 } return stringBuilder.toString() }   </description>
    </item>
    
    <item>
      <title>Lru Cache With Capacity</title>
      <link>https://solairerove.github.io/post/lru-cache-with-capacity/</link>
      <pubDate>Mon, 31 May 2021 19:43:41 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/lru-cache-with-capacity/</guid>
      <description>lru cache with capacity
1 2 3 4 5 6 7 8 9 10 11 12 13  open class LRUCacheWithCapacity&amp;lt;K, V&amp;gt;( private val capacity: Int, loadFactor: Float = 0.75F, accessOrder: Boolean = true ) : LinkedHashMap&amp;lt;K, V&amp;gt;( capacity, loadFactor, accessOrder ) { override fun removeEldestEntry(eldest: MutableMap.MutableEntry&amp;lt;K, V&amp;gt;?): Boolean { return this.size &amp;gt; capacity } }   </description>
    </item>
    
    <item>
      <title>Longest Substring Without Duplication</title>
      <link>https://solairerove.github.io/post/longest-substring-without-duplication/</link>
      <pubDate>Fri, 28 May 2021 17:56:39 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/longest-substring-without-duplication/</guid>
      <description>Input: &amp;ldquo;qvfwpccitm&amp;rdquo;
Output: &amp;ldquo;qvfwpc&amp;rdquo; \
longest substring without duplication
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // O(n) time | O(n) space fun longestSubstringWithoutDuplication(s: String): String { val charToLastIdx = mutableMapOf&amp;lt;Char, Int&amp;gt;() var longest = Pair(0, 1) var low = 0 for (i in s.indices) { val char = s[i] if (char in charToLastIdx) { low = max(low, charToLastIdx[char]!</description>
    </item>
    
    <item>
      <title>Kadane</title>
      <link>https://solairerove.github.io/post/kadane/</link>
      <pubDate>Thu, 27 May 2021 19:45:49 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/kadane/</guid>
      <description>Input: [12, 11, -16, -14, -15, -9, 5, -20, 3, 7, -7]
Output: 23
kadane
1 2 3 4 5 6 7 8 9 10 11 12  // O(n) time | O(1) space fun kadane(arr: List&amp;lt;Int&amp;gt;): Int { var curr = arr[0] var max = arr[0] for (i in 1 until arr.size) { curr = max(arr[i], curr + arr[i]) max = max(curr, max) } return max }   </description>
    </item>
    
    <item>
      <title>Minimum Chars for Words</title>
      <link>https://solairerove.github.io/post/minimum-chars-for-words/</link>
      <pubDate>Wed, 26 May 2021 18:44:10 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/minimum-chars-for-words/</guid>
      <description>Input: [&amp;ldquo;only&amp;rdquo;, &amp;ldquo;after&amp;rdquo;, &amp;ldquo;we&amp;rdquo;, &amp;ldquo;have&amp;rdquo;, &amp;ldquo;lost&amp;rdquo;, &amp;ldquo;everything&amp;rdquo;]
Output: [o, n, l, y, a, f, t, e, e, r, w, h, v, s, i, g] \
minimum chars for words
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // O(n * l) time | O(c) space // n is number of words // l is length of longest word // c is number of unique chars fun minimumCharsForWords(words: List&amp;lt;String&amp;gt;): List&amp;lt;Char&amp;gt; { val maxCharFreq = mutableMapOf&amp;lt;Char, Int&amp;gt;() for (word in words) { val charFreq = mutableMapOf&amp;lt;Char, Int&amp;gt;() word.</description>
    </item>
    
    <item>
      <title>Reverse Words in String</title>
      <link>https://solairerove.github.io/post/reverse-words-in-string/</link>
      <pubDate>Tue, 25 May 2021 18:43:36 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/reverse-words-in-string/</guid>
      <description>Input: &amp;ldquo;anything. do to free we&amp;rsquo;re that everything lost we&amp;rsquo;ve after only It&amp;rsquo;s&amp;rdquo;
Output: &amp;ldquo;It&amp;rsquo;s only after we&amp;rsquo;ve lost everything that we&amp;rsquo;re free to do anything.&amp;rdquo; \
reverse words in string
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // O(n) time | O(n) space fun reverseWordsInString(s: String): String { val chars = s.</description>
    </item>
    
    <item>
      <title>Valid IP Addresses</title>
      <link>https://solairerove.github.io/post/valid-ip-addresses/</link>
      <pubDate>Mon, 24 May 2021 20:36:15 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/valid-ip-addresses/</guid>
      <description>Input: &amp;ldquo;19216801&amp;rdquo;
Output: [19.216.80.1, 192.16.80.1, 192.168.0.1]
valid ip addresses
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import kotlin.math.min // O(1) time | O(1) space fun validIPAddresses(s: String): List&amp;lt;String&amp;gt; { val n = s.length val addresses = mutableListOf&amp;lt;String&amp;gt;() for (i in 1 until min(n, 4)) { val parts = mutableListOf(&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34;) parts[0] = s.</description>
    </item>
    
    <item>
      <title>Product Sum</title>
      <link>https://solairerove.github.io/post/product-sum/</link>
      <pubDate>Fri, 21 May 2021 14:12:31 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/product-sum/</guid>
      <description>Input: [1, [2, [3]]]
Output: 23
product sum
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // O(n) time | O(d) space // n is total number of elements // d is max depth fun productSum(arr: List&amp;lt;*&amp;gt;): Int { return productSum(arr, 1) } fun productSum(arr: List&amp;lt;*&amp;gt;, multiplier: Int): Int { var sum = 0 for (el in arr) { sum += if (el is List&amp;lt;*&amp;gt;) { productSum(el, multiplier + 1) } else { el as Int } } return sum * multiplier }   </description>
    </item>
    
    <item>
      <title>Non Repeating Char Pivot</title>
      <link>https://solairerove.github.io/post/non-repeating-char-pivot/</link>
      <pubDate>Thu, 20 May 2021 23:08:17 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/non-repeating-char-pivot/</guid>
      <description>Input: &amp;ldquo;sptiroksoz&amp;rdquo;
Output: 1
non repeating char pivot
1 2 3 4 5 6 7 8 9 10 11 12  // O(n) time | O(n) space fun nonRepeatingCharPivot(s: String): Int { val freq = mutableMapOf&amp;lt;Char, Int&amp;gt;() s.forEach { freq[it] = freq.getOrDefault(it, 0) + 1 } for (i in s.indices) { if (freq[s[i]] == 1) return i } return -1 }   </description>
    </item>
    
    <item>
      <title>Generate Document</title>
      <link>https://solairerove.github.io/post/generate-document/</link>
      <pubDate>Wed, 19 May 2021 09:09:38 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/generate-document/</guid>
      <description>Input: chars = &amp;ldquo;abcabc&amp;rdquo;, doc = &amp;ldquo;aabbcc&amp;rdquo;
Output: true
generate document
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // O(n + m) time | O(c) space // n is number of chars // m is document length // c is number of unique chars fun generateDocument(chars: String, doc: String): Boolean { val freq = mutableMapOf&amp;lt;Char, Int&amp;gt;() for (c in chars) { if (c !</description>
    </item>
    
    <item>
      <title>Run Length Encoding</title>
      <link>https://solairerove.github.io/post/run-length-encoding/</link>
      <pubDate>Tue, 18 May 2021 20:31:47 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/run-length-encoding/</guid>
      <description>Input: &amp;ldquo;xxxxxxyyyйййй&amp;rdquo;
Output: &amp;ldquo;6x3y4й&amp;rdquo;
 run length encoding  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // O(n) time | O(n) space fun runLengthEncoding(s: String): String { val n = s.length val encoded = mutableListOf&amp;lt;Char&amp;gt;() var len = 1 for (i in 1 until n) { val currChar = s[i] val prevChar = s[i - 1] if (currChar !</description>
    </item>
    
    <item>
      <title>Caesar Cipher Encryptor</title>
      <link>https://solairerove.github.io/post/caesar-cipher-encryptor/</link>
      <pubDate>Mon, 17 May 2021 19:58:00 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/caesar-cipher-encryptor/</guid>
      <description>Input: &amp;ldquo;abc&amp;rdquo;
Output: &amp;ldquo;cde&amp;rdquo;
caesar cipher encryptor
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // O(n) time | O(n) space fun caesarCipherEncryptor(s: String, k: Int): String { val newLetters = mutableListOf&amp;lt;Char&amp;gt;() val key = k % 26 s.forEach { newLetters.add(getNewLetter(it, key)) } return newLetters.joinToString(&amp;#34;&amp;#34;) } fun getNewLetter(letter: Char, key: Int): Char { val newLetterCode = letter.toInt() + key return if (newLetterCode &amp;lt;= 122) { newLetterCode.</description>
    </item>
    
    <item>
      <title>Merge Overlapping Intervals</title>
      <link>https://solairerove.github.io/post/merge-overlapping-intervals/</link>
      <pubDate>Fri, 14 May 2021 15:34:18 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/merge-overlapping-intervals/</guid>
      <description>Input: [[3, 5], [1, 4], [6, 7]]
Output: [[1, 5], [6, 7]]
merge overlapping intervals
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // O(nlog(n)) time | O(n) space fun mergeOverlappingIntervals(intervals: List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt;): List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt; { val sorted = intervals.toMutableList() .sortedWith { a, b -&amp;gt; a[0].compareTo(b[0]) } .map { it.toMutableList() } val merged = mutableListOf&amp;lt;MutableList&amp;lt;Int&amp;gt;&amp;gt;() var curr = sorted[0] merged.</description>
    </item>
    
    <item>
      <title>First Duplicate Value</title>
      <link>https://solairerove.github.io/post/first-duplicate-value/</link>
      <pubDate>Thu, 13 May 2021 12:40:48 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/first-duplicate-value/</guid>
      <description>Input: [2, 3, 2, 6, 6, 5, 3, 6]
Output: 2
Naive O(n) time | O(n) space solution is to use set and contains check
first duplicate value
1 2 3 4 5 6 7 8 9 10  // O(n) time | O(1) space fun firstDuplicateValue(arr: MutableList&amp;lt;Int&amp;gt;): Int { for (el in arr) { val absEl = abs(el) if (arr[absEl - 1] &amp;lt; 0) return absEl arr[absEl - 1] *= -1 } return -1 }   </description>
    </item>
    
    <item>
      <title>Array of Products</title>
      <link>https://solairerove.github.io/post/array-of-products/</link>
      <pubDate>Wed, 12 May 2021 21:31:54 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/array-of-products/</guid>
      <description>Input: [1, 2, 3, 4, 6]
Output: [144, 72, 48, 36, 24]
array of products
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // O(n) time | O(n) space fun arrayOfProducts(arr: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; { val n = arr.size val products = MutableList(n) { 1 } var low = 1 for (i in 0 until n) { products[i] = low low *= arr[i] } var high = 1 for (i in n - 1 downTo 0) { products[i] *= high high *= arr[i] } return products }   </description>
    </item>
    
    <item>
      <title>Group Anagrams</title>
      <link>https://solairerove.github.io/post/group-anagrams/</link>
      <pubDate>Tue, 11 May 2021 21:08:31 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/group-anagrams/</guid>
      <description>Input: [&amp;ldquo;funeral&amp;rdquo;, &amp;ldquo;realfun&amp;rdquo;, &amp;ldquo;debitcard&amp;rdquo;, &amp;ldquo;badcredit&amp;rdquo;, &amp;ldquo;bobmarley&amp;rdquo;, &amp;ldquo;marbleboy&amp;rdquo;]
Output: [[funeral, realfun], [debitcard, badcredit], [bobmarley, marbleboy]]
group anagrams
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // O(w * nlog(n)) time | O(wn) space // w - number of words // n - length of longest word fun groupAnagrams(words: List&amp;lt;String&amp;gt;): List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; { val anagrams = mutableMapOf&amp;lt;String, MutableList&amp;lt;String&amp;gt;&amp;gt;() for (word in words) { val sortedWord = word.</description>
    </item>
    
    <item>
      <title>Longest Palindrome</title>
      <link>https://solairerove.github.io/post/longest-palindrome/</link>
      <pubDate>Mon, 10 May 2021 20:33:20 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/longest-palindrome/</guid>
      <description>Input: s = &amp;ldquo;arpkqqkpfkpdp&amp;rdquo;
Output: pkqqkp
longest palindrome
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // O(n^2) time | O(n) space fun longestPalindrome(s: String): String { var longest = listOf(0, 1) for (i in 1 until s.length) { val odd = getLongestPalindrome(s, i - 1, i + 1) val even = getLongestPalindrome(s, i - 1, i) val curr = if (odd[1] - odd[0] &amp;gt; even[1] - odd[0]) odd else even longest = if (longest[1] - longest[0] &amp;gt; curr[1] - curr[0]) longest else curr } return s.</description>
    </item>
    
    <item>
      <title>Tournament Winner</title>
      <link>https://solairerove.github.io/post/tournament-winner/</link>
      <pubDate>Fri, 07 May 2021 15:18:41 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/tournament-winner/</guid>
      <description>Input:
1 2 3 4 5 6 7  val competitions = listOf( listOf(&amp;#34;Kotlin&amp;#34;, &amp;#34;Java&amp;#34;), listOf(&amp;#34;Java&amp;#34;, &amp;#34;Python&amp;#34;), listOf(&amp;#34;Python&amp;#34;, &amp;#34;Kotlin&amp;#34;) ) val results = listOf(1, 0, 0)   Output: Kotlin
tournament winner
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // O(n) time | O(k) space // n - number of competitions // k - number of teams fun tournamentWinner(competitions: List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;, results: List&amp;lt;Int&amp;gt;): String { var winner = &amp;#34;&amp;#34; val teamToScore = mutableMapOf(winner to 0) for (i in competitions.</description>
    </item>
    
    <item>
      <title>Non Constructable Change</title>
      <link>https://solairerove.github.io/post/non-constructable-change/</link>
      <pubDate>Thu, 06 May 2021 13:40:20 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/non-constructable-change/</guid>
      <description>Input: arr = [2, 3, 1, 1, 2, 13]
Output: 10
non constructable change
1 2 3 4 5 6 7 8 9 10 11 12 13  // O(nlog(n)) time | O(1) space fun nonConstructableChange(arr: MutableList&amp;lt;Int&amp;gt;): Int { arr.sort() var change = 0 for (el in arr) { if (el &amp;gt; change + 1) return change + 1 change += el } return change + 1 }   </description>
    </item>
    
    <item>
      <title>Sort Squared Array</title>
      <link>https://solairerove.github.io/post/sort-squared-array/</link>
      <pubDate>Wed, 05 May 2021 13:43:52 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/sort-squared-array/</guid>
      <description>Input: arr = [-2, -1, 3, 4, 6, 7, 9, 10]
Output: [1, 4, 9, 16, 36, 49, 81, 100]
sorted squared array
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // O(n) time | O(n) space fun sortedSquaredArray(arr: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; { val n = arr.size val sortedSquared = MutableList(n) { 0 } var low = 0 var high = n - 1 for (i in n - 1 downTo 0) { val lowEl = arr[low] val highEl = arr[high] if (abs(highEl) &amp;gt; abs(lowEl)) { sortedSquared[i] = highEl * highEl high-- } else { sortedSquared[i] = lowEl * lowEl low++ } } return sortedSquared }   </description>
    </item>
    
    <item>
      <title>Smallest Difference</title>
      <link>https://solairerove.github.io/post/smallest-difference/</link>
      <pubDate>Tue, 04 May 2021 23:44:48 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/smallest-difference/</guid>
      <description>Input: arrOne=[2, -9, 0, 14, 1, -8, -3, -1, 8, -6, 5, -5], arrTwo=[15, -8, 3, 1, 7, -10, 2, -1, 4, -3, 17, -2] Output: [-8, -8]
smallest difference
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // O(nlog(n) + mlog(m)) time | O(1) space fun smallestDifference(arrOne: MutableList&amp;lt;Int&amp;gt;, arrTwo: MutableList&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; { arrOne.</description>
    </item>
    
    <item>
      <title>Longest Peak</title>
      <link>https://solairerove.github.io/post/longest-peak/</link>
      <pubDate>Tue, 04 May 2021 13:03:22 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/longest-peak/</guid>
      <description>Input: arr = [3, -4, 7, 12, 4, 20, 15, 6, -2, 5, 16, 11, 1]
Output: 5
longest peak
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // O(n) time | O(1) space fun longestPeak(arr: List&amp;lt;Int&amp;gt;): Int { var longestPeakLen = 0 var i = 1 while (i &amp;lt; arr.size - 1) { val isPeak = arr[i] &amp;gt; arr[i - 1] &amp;amp;&amp;amp; arr[i] &amp;gt; arr[i + 1] if (!</description>
    </item>
    
    <item>
      <title>Spiral Traverse</title>
      <link>https://solairerove.github.io/post/spiral-traverse/</link>
      <pubDate>Mon, 03 May 2021 20:43:19 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/spiral-traverse/</guid>
      <description>Input: arr = [[8, 2, -2, -4, 1], [3, 5, 10, 6, 4], [4, 10, -2, 1, 9], [6, 9, -4, 0, -1]]
Output: [8, 2, -2, -4, 1, 4, 9, -1, 0, -4, 9, 6, 4, 3, 5, 10, 6, 1, -2, 10]
spiral traverse
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // O(n) time | O(n) space fun spiralTraverse(arr: List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt;): List&amp;lt;Int&amp;gt; { val res = mutableListOf&amp;lt;Int&amp;gt;() var lowRow = 0 var highRow = arr.</description>
    </item>
    
    <item>
      <title>Monotonic Array</title>
      <link>https://solairerove.github.io/post/monotonic-array/</link>
      <pubDate>Fri, 30 Apr 2021 16:16:13 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/monotonic-array/</guid>
      <description>Input: arr = [-10, -9, -4, 0, 1, 2, 3, 5, 9, 11, 12, 14, 17]
Output: true
monotonic array
1 2 3 4 5 6 7 8 9 10 11 12 13 14  // O(n) time | O(1) space fun isMonotonic(arr: List&amp;lt;Int&amp;gt;): Boolean { var isIncreasing = true var isDecreasing = true for (i in 1 until arr.size) { when { arr[i - 1] &amp;lt; arr[i] -&amp;gt; isDecreasing = false arr[i - 1] &amp;gt; arr[i] -&amp;gt; isIncreasing = false } } return isIncreasing || isDecreasing }   </description>
    </item>
    
    <item>
      <title>Move Element to the End</title>
      <link>https://solairerove.github.io/post/move-element-to-the-end/</link>
      <pubDate>Fri, 30 Apr 2021 16:06:24 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/move-element-to-the-end/</guid>
      <description>Input: arr = [-9, -7, 2, -4, 0, 2, 3, 4, 5, 7], k = 2
Output: [-9, -7, 7, -4, 0, 5, 3, 4, 2, 2]
move element to the end
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // O(n) time | O(1) space fun moveElementToTheEnd(arr: MutableList&amp;lt;Int&amp;gt;, k: Int) { var low = 0 var high = arr.</description>
    </item>
    
    <item>
      <title>Three Number Sum</title>
      <link>https://solairerove.github.io/post/three-number-sum/</link>
      <pubDate>Thu, 29 Apr 2021 15:13:22 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/three-number-sum/</guid>
      <description>Input: arr = [-9, -7, -6, -4, 0, 2, 3, 4, 5, 7], target = -1
Output: [[-9, 3, 5], [-7, 2, 4], [-6, 0, 5], [-6, 2, 3], [-4, 0, 3]]
three number sum
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // O(n^2) time | O(n) space fun threeNumberSum(arr: MutableList&amp;lt;Int&amp;gt;, target: Int): List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt; { arr.</description>
    </item>
    
    <item>
      <title>Validate Subsequence</title>
      <link>https://solairerove.github.io/post/validate-subsequence/</link>
      <pubDate>Thu, 29 Apr 2021 14:39:58 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/validate-subsequence/</guid>
      <description>validate subsequence
1 2 3 4 5 6 7 8 9 10 11  // O(n) time | O(1) space fun validateSubsequence(arr: List&amp;lt;Int&amp;gt;, subsequence: List&amp;lt;Int&amp;gt;): Boolean { var seqIdx = 0 for (el in arr) { if (seqIdx == subsequence.size) break if (el == subsequence[seqIdx]) seqIdx++ } return seqIdx == subsequence.size }   </description>
    </item>
    
    <item>
      <title>Shell Sort</title>
      <link>https://solairerove.github.io/post/shell-sort/</link>
      <pubDate>Wed, 28 Apr 2021 22:03:49 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/shell-sort/</guid>
      <description>shell sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // O(nlog(n)) time | O(1) space fun shellSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size // 3x+1 increment sequence: 1, 4, 13, 40, 121, 364, 1093,  var h = 1 while (h &amp;lt; n / 3) h = h * 3 + 1 while (h &amp;gt;= 1) { // h-sort  for (i in h until n) { for (j in i downTo h step h) { if (arr[j] &amp;lt; arr[j - h]) { swap(arr, j, j - h) } } } h /= 3 } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp }   </description>
    </item>
    
    <item>
      <title>Valid Starting City</title>
      <link>https://solairerove.github.io/post/valid-starting-city/</link>
      <pubDate>Tue, 27 Apr 2021 22:30:10 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/valid-starting-city/</guid>
      <description>Input: distances = [10, 15, 10, 25, 5], fuel = [1, 2, 3, 1, 2], mpg = 5
Output: 4
valid starting city
type of leetcode destination-city
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // O(n) time | O(1) space fun validStartingCity(distances: List&amp;lt;Int&amp;gt;, fuel: List&amp;lt;Int&amp;gt;, mpg: Int): Int { var currMiles = 0 var idx = 0 var totalMiles = 0 for (i in 1 until distances.</description>
    </item>
    
    <item>
      <title>Task Assignment</title>
      <link>https://solairerove.github.io/post/task-assignment/</link>
      <pubDate>Tue, 27 Apr 2021 22:23:32 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/task-assignment/</guid>
      <description>Find the fastest time to complete all tasks, if worker can proceed only 2 tasks
k is a number of workers
tasks is an array of task duration
Input: tasks = [2, 4, 6, 1, 5, 3], k = 3
Output: [[3, 2], [0, 4], [5, 1]]
task assignment
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // O(nlog(n)) time | O(n) space fun taskAssignment(tasks: MutableList&amp;lt;Int&amp;gt;, k: Int): List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt; { val paired = mutableListOf&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt;() val taskDurationToIndices = taskDurationToIndices(tasks) tasks.</description>
    </item>
    
    <item>
      <title>Tandem Bicycle</title>
      <link>https://solairerove.github.io/post/tandem-bicycle/</link>
      <pubDate>Mon, 26 Apr 2021 22:21:31 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/tandem-bicycle/</guid>
      <description>Найти максимальную сумму скоростей тандема велосипедистов.
Input: red = [1, 5, 9, 4, 6], blue = [4, 8, 6, 5, 3]
Output: 34
tandem bicycle
type of leet code
1 2 3 4 5 6 7 8 9 10 11 12 13  // O(nlog(n)) time | O(1) space fun tandemBicycle(red: MutableList&amp;lt;Int&amp;gt;, blue: MutableList&amp;lt;Int&amp;gt;): Int { red.sort() blue.sort() val n = red.size var total = 0 for (i in 0 until n) { total += max(red[i], blue[n - 1 - i]) } return total }   </description>
    </item>
    
    <item>
      <title>Merge Sort Bu</title>
      <link>https://solairerove.github.io/post/merge-sort-bu/</link>
      <pubDate>Mon, 26 Apr 2021 21:11:12 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/merge-sort-bu/</guid>
      <description>princeton mergesort
merge sort bu
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // O(nlog(n)) time | O(n) space fun mergeSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size val aux = MutableList(n) { i -&amp;gt; i } var len = 1 while (len &amp;lt; n) { for (low in 0 until n - len step 2 * len) { val mid = low + len - 1 val high = min(low + 2 * len - 1, n - 1) merge(arr, aux, low, mid, high) } len *= 2 } } fun merge(arr: MutableList&amp;lt;Int&amp;gt;, aux: MutableList&amp;lt;Int&amp;gt;, low: Int, mid: Int, high: Int) { for (k in low.</description>
    </item>
    
    <item>
      <title>Height Checker</title>
      <link>https://solairerove.github.io/post/height-checker/</link>
      <pubDate>Fri, 23 Apr 2021 17:49:34 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/height-checker/</guid>
      <description>Input: red = [1, 5, 9, 4, 6], blue = [4, 8, 6, 5, 3]
Output: false
height checker
type of leet code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // O(nlog(n)) time | O(1) space fun heightChecker(red: MutableList&amp;lt;Int&amp;gt;, blue: MutableList&amp;lt;Int&amp;gt;): Boolean { red.sortDescending() blue.sortDescending() val firstRow = if (red[0] &amp;lt; blue[0]) 1 else 0 for (i in 0 until red.</description>
    </item>
    
    <item>
      <title>Sort K Sorted Array</title>
      <link>https://solairerove.github.io/post/sort-k-sorted-array/</link>
      <pubDate>Thu, 22 Apr 2021 23:48:43 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/sort-k-sorted-array/</guid>
      <description>Input: arr = [6, 5, 3, 2, 8, 10, 9], k = 3
Output: [2, 3, 5, 6, 8, 9, 10]
merge k sorted arrays
min heap
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // O(nlog(k)) time | O(k) space // n - total elements, k is k fun sortKSortedArrays(arr: MutableList&amp;lt;Int&amp;gt;, k: Int) { val sliceIdx = if (k + 1 &amp;lt; arr.</description>
    </item>
    
    <item>
      <title>Radix Sort</title>
      <link>https://solairerove.github.io/post/radix-sort/</link>
      <pubDate>Wed, 21 Apr 2021 22:09:42 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/radix-sort/</guid>
      <description>radix sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // O(d * (n + m)) time | O(n + m) space fun radixSort(arr: MutableList&amp;lt;Int&amp;gt;) { // find max  var max = arr[0] arr.forEach { if (it &amp;gt; max) max = it } var digit = 0 while (max / 10.</description>
    </item>
    
    <item>
      <title>Merge K Sorted Arrays</title>
      <link>https://solairerove.github.io/post/merge-k-sorted-arrays/</link>
      <pubDate>Tue, 20 Apr 2021 22:30:02 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/merge-k-sorted-arrays/</guid>
      <description>Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
leetcode
merge k sorted arrays
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  // O(nlog(k) + k) time | O(n + k) space // n - total elements, k - number of arrays fun mergeKSortedArrays(arrays: List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt;): List&amp;lt;Int&amp;gt; { val res = mutableListOf&amp;lt;Int&amp;gt;() val min = mutableListOf&amp;lt;Element&amp;gt;() for (i in arrays.</description>
    </item>
    
    <item>
      <title>Pivot Index</title>
      <link>https://solairerove.github.io/post/pivot-index/</link>
      <pubDate>Tue, 20 Apr 2021 20:20:36 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/pivot-index/</guid>
      <description>leetcode
pivot index
1 2 3 4 5 6 7 8 9 10 11  // O(n) time | O(1) space fun pivotIndex(arr: List&amp;lt;Int&amp;gt;): Int { val total = arr.sum() var sum = 0 for (i in arr.indices) { if (sum * 2 == total - arr[i]) return i sum += arr[i] } return -1 }   </description>
    </item>
    
    <item>
      <title>Reverse Linked List</title>
      <link>https://solairerove.github.io/post/reverse-linked-list/</link>
      <pubDate>Tue, 20 Apr 2021 19:47:52 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/reverse-linked-list/</guid>
      <description>leetcode
reverse linked list
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class ListNode(var value: Int) { var next: ListNode? = null } // O(n) time | O(1) space fun reverseList(head: ListNode?): ListNode? { var prev: ListNode? = null var curr: ListNode? = head while (curr != null) { val next = curr.next curr.next = prev prev = curr curr = next } return prev }   </description>
    </item>
    
    <item>
      <title>Fixed Point</title>
      <link>https://solairerove.github.io/post/fixed-point/</link>
      <pubDate>Mon, 19 Apr 2021 22:58:07 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/fixed-point/</guid>
      <description>1  index == arr[index]   fixed point
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // O(log(n)) time | O(1) space fun searchFixedPoint(arr: List&amp;lt;Int&amp;gt;): Int { var low = 0 var high = arr.size - 1 while (low &amp;lt;= high) { val mid = low + (high - low) / 2 when { arr[mid] &amp;lt; mid -&amp;gt; low = mid + 1 arr[mid] == mid &amp;amp;&amp;amp; mid == 0 -&amp;gt; return mid arr[mid] == mid &amp;amp;&amp;amp; arr[mid - 1] &amp;lt; mid - 1 -&amp;gt; return mid else -&amp;gt; high = mid - 1 } } return -1 }   </description>
    </item>
    
    <item>
      <title>Find First and Last Position of Element in Sorted Array</title>
      <link>https://solairerove.github.io/post/find-first-and-last-position-of-element/</link>
      <pubDate>Mon, 19 Apr 2021 20:02:54 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/find-first-and-last-position-of-element/</guid>
      <description>leetcode
search range
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // O(log(n)) time | O(1) space fun searchRange(arr: List&amp;lt;Int&amp;gt;, target: Int): Pair&amp;lt;Int, Int&amp;gt; { return Pair(findFirstIndex(arr, target), findLastIndex(arr, target)) } fun findFirstIndex(arr: List&amp;lt;Int&amp;gt;, target: Int): Int { var idx = -1 var low = 0 var high = arr.</description>
    </item>
    
    <item>
      <title>Rotated Binary Search</title>
      <link>https://solairerove.github.io/post/rotated-binary-search/</link>
      <pubDate>Fri, 16 Apr 2021 23:51:48 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/rotated-binary-search/</guid>
      <description>leetcode
rotated binary search
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // O(log(n)) time | O(1) space fun rotatedBinarySearch(arr: List&amp;lt;Int&amp;gt;, k: Int): Int { var low = 0 var high = arr.size - 1 while (low &amp;lt;= high) { val mid = low + (high - low) / 2 if (arr[mid] == k) return mid else if (arr[low] &amp;lt;= k) { if (k &amp;lt; arr[mid] &amp;amp;&amp;amp; k &amp;gt;= arr[low]) high = mid - 1 else low = mid + 1 } else { if (k &amp;gt; arr[mid] &amp;amp;&amp;amp; k &amp;lt;= arr[high]) low = mid + 1 else high = mid - 1 } } return -1 }   </description>
    </item>
    
    <item>
      <title>Search in Matrix</title>
      <link>https://solairerove.github.io/post/search-in-matrix/</link>
      <pubDate>Thu, 15 Apr 2021 23:26:27 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/search-in-matrix/</guid>
      <description>leetcode
third maximum number
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // O(n + m) time | O(1) space fun searchInMatrix(matrix: List&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt;, target: Int): List&amp;lt;Int&amp;gt; { var row = 0 var col = matrix[0].size - 1 while (row &amp;lt; matrix.size &amp;amp;&amp;amp; col &amp;gt;= 0) { when { matrix[row][col] &amp;lt; target -&amp;gt; row++ matrix[row][col] &amp;gt; target -&amp;gt; col-- else -&amp;gt; return listOf(row, col) } } return listOf(-1, -1) }   </description>
    </item>
    
    <item>
      <title>Third Maximum Number</title>
      <link>https://solairerove.github.io/post/third-maximum-number/</link>
      <pubDate>Thu, 15 Apr 2021 22:56:13 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/third-maximum-number/</guid>
      <description>leetcode
third maximum number
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // O(n) time | O(1) space fun thirdMaximumNumber(arr: List&amp;lt;Int&amp;gt;): Int { val largestNumbers = mutableListOf(Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE) for (element in arr) { when { element &amp;gt; largestNumbers[2] -&amp;gt; shift(largestNumbers, element, 2) element &amp;gt; largestNumbers[1] -&amp;gt; shift(largestNumbers, element, 1) element &amp;gt; largestNumbers[0] -&amp;gt; shift(largestNumbers, element, 0) } } return largestNumbers[0] } fun shift(arr: MutableList&amp;lt;Int&amp;gt;, toInsert: Int, position: Int) { for (i in 0 until position + 1) { arr[i] = if (i == position) toInsert else arr[i + 1] } }   </description>
    </item>
    
    <item>
      <title>Dutch National Flag</title>
      <link>https://solairerove.github.io/post/dutch-national-flag/</link>
      <pubDate>Wed, 14 Apr 2021 23:04:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/dutch-national-flag/</guid>
      <description>Дан массив для сортировки, и массив числе в порядке, в котором нужно отсортировать.
Есть несколько решений.
 пройтись и посчитать сколько встречается элемент и потом перезаписать выставить за проход первый элемент, за второй выставить третий элемент дейкстра стайл  dutch national flag
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // O(n) time | O(1) space fun sortColors(arr: MutableList&amp;lt;Int&amp;gt;, colors: List&amp;lt;Int&amp;gt;) { var lt = 0 var i = 0 var gt = arr.</description>
    </item>
    
    <item>
      <title>Quick Select</title>
      <link>https://solairerove.github.io/post/quick-select/</link>
      <pubDate>Tue, 13 Apr 2021 22:01:11 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/quick-select/</guid>
      <description>quick select
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // O(n) time | O(1) space fun quickSelect(arr: MutableList&amp;lt;Int&amp;gt;, k: Int): Int { var low = 0 var high = arr.size - 1 while (low &amp;lt; high) { val j = partition(arr, low, high) when { j &amp;lt; k -&amp;gt; low = j + 1 j &amp;gt; k -&amp;gt; high = j - 1 else -&amp;gt; return arr[j] } } return arr[low] } fun partition(arr: MutableList&amp;lt;Int&amp;gt;, low: Int, high: Int): Int { var i = low var j = high + 1 val v = arr[low] while (true) { while (arr[++i] &amp;lt; v) if (i == high) break while (v &amp;lt; arr[--j]) if (j == low) break if (j &amp;lt;= i) break swap(arr, i, j) } swap(arr, low, j) return j } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp }   </description>
    </item>
    
    <item>
      <title>Two Numbers Sum</title>
      <link>https://solairerove.github.io/post/two-numbers-sum/</link>
      <pubDate>Mon, 12 Apr 2021 22:06:31 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/two-numbers-sum/</guid>
      <description>Дан массив. Вернуть массив из элементов, сумма которых равна заданной. \
 Наивный подход на n^2 пересуммировать все возможные элементы. \ Линейная сложность с помощью мапы или сета. \ Константную память можно получить,
если отсортировать массив,
и почти как в бинарном поиске обновлять верхний и нижний индексы  two number sum
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // O(n) time | O(n) space fun twoNumberSumSet(arr: MutableList&amp;lt;Int&amp;gt;, targetSum: Int): List&amp;lt;Int&amp;gt; { val numbers = hashSetOf&amp;lt;Int&amp;gt;() for (a in arr) { val potential = targetSum - a if (numbers.</description>
    </item>
    
    <item>
      <title>Count Sort</title>
      <link>https://solairerove.github.io/post/count-sort/</link>
      <pubDate>Fri, 09 Apr 2021 00:11:24 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/count-sort/</guid>
      <description>Сортировка подсчетом.
Считаем количество вхождений каждого элемента.
Потом куммулятивную сумму и так находим нужную позицию элемента.
count sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // O(n + m) time | O(n) space fun countSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size // find max  var max = arr[0] arr.</description>
    </item>
    
    <item>
      <title>Bisect left</title>
      <link>https://solairerove.github.io/post/bisect_left/</link>
      <pubDate>Thu, 08 Apr 2021 22:24:47 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/bisect_left/</guid>
      <description>binary select left
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // O(log(n)) time | O(1) space fun biSectLeft(arr: List&amp;lt;Int&amp;gt;, target: Int, lo: Int = 0, hi: Int = arr.size): Int { val n = arr.size if (n == 0) return 0 var low = lo var high = hi if (target &amp;lt; arr[low]) return low if (target &amp;gt; arr[high - 1]) return high while (true) { if (low + 1 == high) { return if (target == arr[low]) low else (low + 1) } val mid = low + (high - low) / 2 when { target &amp;lt;= arr[mid] -&amp;gt; high = mid else -&amp;gt; low = mid } } }   </description>
    </item>
    
    <item>
      <title>Bisect right</title>
      <link>https://solairerove.github.io/post/bisect_right/</link>
      <pubDate>Thu, 08 Apr 2021 22:24:43 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/bisect_right/</guid>
      <description>binary select right
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // O(log(n)) time | O(1) space fun biSectRight(arr: List&amp;lt;Int&amp;gt;, target: Int, lo: Int = 0, hi: Int = arr.size): Int { val n = arr.size if (n == 0) return 0 var low = lo var high = hi if (target &amp;lt; arr[low]) return low if (target &amp;gt; arr[high - 1]) return high while (true) { if (low + 1 == high) { return low + 1 } val mid = low + (high - low) / 2 when { target &amp;lt; arr[mid] -&amp;gt; high = mid else -&amp;gt; low = mid } } }   </description>
    </item>
    
    <item>
      <title>Quick Sort 3 Way</title>
      <link>https://solairerove.github.io/post/quick-sort-3-way/</link>
      <pubDate>Tue, 06 Apr 2021 20:10:04 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/quick-sort-3-way/</guid>
      <description>Вариант быстрой сортировки с трехчастным разбиением для массивов с низкой энтропией.
a[low]..a[lt - 1] &amp;lt;= a[j] &amp;lt;= a[gt + 1]..a[high] a[lt - 1] = a[j] = a[gt + 1]
princeton quicksort 3 way
quick sort 3 way
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // O(nlog(n)) time | O(log(n)) space fun quickSort(arr: MutableList&amp;lt;Int&amp;gt;, low: Int = 0, high: Int = arr.</description>
    </item>
    
    <item>
      <title>Quick Sort</title>
      <link>https://solairerove.github.io/post/quick-sort/</link>
      <pubDate>Mon, 05 Apr 2021 18:10:55 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/quick-sort/</guid>
      <description>Классический эффективный алгоритм сортировки divide and conquer.
Разбиваем массив и независимо сортируем подмассивы. \
a[low]..a[j - 1] &amp;lt;= a[j] &amp;lt;= a[j + 1]..a[high]
princeton quicksort
quick sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // O(nlog(n)) time | O(log(n)) space fun quickSort(arr: MutableList&amp;lt;Int&amp;gt;, low: Int = 0, high: Int = arr.</description>
    </item>
    
    <item>
      <title>Inversions</title>
      <link>https://solairerove.github.io/post/inversions/</link>
      <pubDate>Wed, 31 Mar 2021 23:10:38 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/inversions/</guid>
      <description>Вытекающая задача из сортировки слиянием.
Смысл решения в том, что мы точно знаем, что i меньше j,
поэтому когда j элемент меньше i, то мы получаем инверсию. \ И раз он меньше, то он будет меньше и всех остальных элементов в части i.
Именно поэтому mid + 1 - i -&amp;gt; просто длина подмассива.
3.2 Подсчет инверсий
inversions
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  // O(nlog(n)) time | O(n) space fun count(arr: MutableList&amp;lt;Int&amp;gt;): Long { val n = arr.</description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://solairerove.github.io/post/merge-sort/</link>
      <pubDate>Fri, 26 Mar 2021 17:28:02 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/merge-sort/</guid>
      <description>Классический эффективный алгоритм сортировки divide and conquer.
Разделяем массив на подмассивы до подмассивов размером 1 и
собираем их в отсортированные подмассивы.
Почему O(nlog(n)).
Потому что у нас всего nlog(n) операций, которые сами по себе O(n).
princeton mergesort
merge sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // O(nlog(n)) time | O(n) space fun mergeSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.</description>
    </item>
    
    <item>
      <title>Min Heap</title>
      <link>https://solairerove.github.io/post/min-heap/</link>
      <pubDate>Thu, 11 Mar 2021 20:27:42 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/min-heap/</guid>
      <description>Main methods:
 build heap sift down sift up insert remove  Node:
 current node -&amp;gt; i child one -&amp;gt; (2 * i) + 1 child two -&amp;gt; (2 * i) + 2 parent node -&amp;gt; (i - 1) / 2  Transform array to heap (heapify)
 foreach parent sink  min heap
Priority Queues
stepik max heap
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  class MinHeap(arr: MutableList&amp;lt;Int&amp;gt;) { private var heap: MutableList&amp;lt;Int&amp;gt; = arr init { val n = arr.</description>
    </item>
    
    <item>
      <title>Heap Sort</title>
      <link>https://solairerove.github.io/post/heap-sort/</link>
      <pubDate>Tue, 09 Mar 2021 17:45:39 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/heap-sort/</guid>
      <description>build heap from array and n time get min element. (naive heap sort)
heap sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // O(nlogn) time | O(1) space fun heapSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (k in n / 2 downTo 1) { sink(arr, k, n) } var k = n while (k &amp;gt; 1) { swap(arr, 1, k--) sink(arr, 1, k) } } fun sink(arr: MutableList&amp;lt;Int&amp;gt;, k: Int, n: Int) { var idx = k while (2 * idx &amp;lt;= n) { var j = 2 * idx if (j &amp;lt; n &amp;amp;&amp;amp; less(arr, j, j + 1)) j++ if (!</description>
    </item>
    
    <item>
      <title>Minimum Waiting Time</title>
      <link>https://solairerove.github.io/post/minimum-waiting-time/</link>
      <pubDate>Mon, 08 Mar 2021 17:27:29 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/minimum-waiting-time/</guid>
      <description>Given non-empty array of positive int, that define time to execute.
Only one query can be executed at time, but in any order.
Get minimal waiting time to execute all queries.
Solid step is ascending sort.
9 6 5 2 3 1 -&amp;gt; 1 2 3 5 6 9 -&amp;gt; 0 + 1 + (1 + 2) + (1 + 2 + 3) + (1 + 2 + 3 + 5) + (1 + 2 + 3 + 5 + 6) = 38</description>
    </item>
    
    <item>
      <title>Huffman Decode</title>
      <link>https://solairerove.github.io/post/huffman-decode/</link>
      <pubDate>Sun, 07 Mar 2021 18:25:44 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/huffman-decode/</guid>
      <description>Формулировка задачи
huffman decode
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // abacabad fun main() { val dictionary = mapOf( Pair(&amp;#34;0&amp;#34;, &amp;#34;a&amp;#34;), Pair(&amp;#34;10&amp;#34;, &amp;#34;b&amp;#34;), Pair(&amp;#34;110&amp;#34;, &amp;#34;c&amp;#34;), Pair(&amp;#34;111&amp;#34;, &amp;#34;d&amp;#34;) ) val s = &amp;#34;01001100100111&amp;#34; val stringBuilder = StringBuilder() var i = 0 while (i &amp;lt; s.length) { var isCodeFound = false var code = s[i].</description>
    </item>
    
    <item>
      <title>Naive Huffman Encode</title>
      <link>https://solairerove.github.io/post/naive-huffman-encode/</link>
      <pubDate>Sun, 07 Mar 2021 15:55:23 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/naive-huffman-encode/</guid>
      <description>Формулировка задачи
naive huffman encode
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  /** * abacabad * 4 14 * a: 0 * b: 10 * c: 110 * d: 111 * 01001100100111 */ fun main() { val s = &amp;#34;abacabad&amp;#34; val letterToFreq = getLetterToFrequency(s = s) val letterWeightStack = getLetterWeightStack(letterToFreq = letterToFreq) val huffmanResult = huffman(letterWeightStack = letterWeightStack) val dictionary = getDictionary(huffmanResult = huffmanResult) val encodedString = encodeString(stringToEncode = s, dictionary = dictionary) println(&amp;#34;${dictionary.</description>
    </item>
    
    <item>
      <title>Number Partition</title>
      <link>https://solairerove.github.io/post/number-partition/</link>
      <pubDate>Thu, 04 Mar 2021 18:55:57 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/number-partition/</guid>
      <description>Формулировка задачи
number partition
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fun main() { var n = 6 val res = mutableListOf&amp;lt;Int&amp;gt;() for (i in 1..n) { if (n - i &amp;gt;= i + 1) { res.add(i) } else { res.add(n) break } n -= i } print(&amp;#34;${res.size}\n&amp;#34;) res.forEach { print(&amp;#34;$it&amp;#34;) } }   </description>
    </item>
    
    <item>
      <title>Knapsack Problem</title>
      <link>https://solairerove.github.io/post/knapsack-problem/</link>
      <pubDate>Thu, 04 Mar 2021 17:58:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/knapsack-problem/</guid>
      <description>Формулировка задачи
knapsack problem
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import java.text.DecimalFormat fun main() { var backPackSize = 50 val items = mutableListOf( Item(worth = 60, volume = 20, worthPerVolume = (60 / 20).toDouble()), Item(worth = 100, volume = 50, worthPerVolume = (100 / 50).</description>
    </item>
    
    <item>
      <title>Segments Covering by Unit</title>
      <link>https://solairerove.github.io/post/segments-covering-by-unit/</link>
      <pubDate>Thu, 04 Mar 2021 13:00:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/segments-covering-by-unit/</guid>
      <description>Даны отрезки на прямой. Найти такие точки, которые лежат на всех заданных отрезках. Найденное множество должно быть минимальным по размеру.
Берем все концы отрезков (как левые, так и правые) и сортируем их. Для каждой точки сохраним номер отрезка. Также каким концом его она является (левым или правым). Учтем, что если есть несколько точек с одной координатой, то сначала будут идти левые концы, потом правые.
Заведём коллекцию, в которой будут храниться номера отрезков, рассматриваемых в данный момент.</description>
    </item>
    
    <item>
      <title>Palindrome Check</title>
      <link>https://solairerove.github.io/post/palindrome-check/</link>
      <pubDate>Wed, 03 Mar 2021 16:56:50 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/palindrome-check/</guid>
      <description>Палиндром - строка, которая одинаково читается в обоих направлениях.
palindrome check
1 2 3 4 5 6 7 8 9  // O(n) time | O(1) space fun isPalindrome(s: String): Boolean { for (i in s.indices) { if (s[i] != s[s.length - 1 - i]) { return false } } return true }   </description>
    </item>
    
    <item>
      <title>Highest Common Factor</title>
      <link>https://solairerove.github.io/post/highest-common-factor/</link>
      <pubDate>Tue, 02 Mar 2021 13:27:30 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/highest-common-factor/</guid>
      <description>Алгоритм Евклида для нахождения наибольшего общего делителя.
gcd
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  fun gcd(p: Int, q: Int): Int { if (q == 0) { return p } val r = p % q return gcd(q, r) } private fun iterativeGcd(p: Int, q: Int): Int { var a = p var b = q while (b !</description>
    </item>
    
    <item>
      <title>Fibonacci</title>
      <link>https://solairerove.github.io/post/fibonacci/</link>
      <pubDate>Tue, 02 Mar 2021 11:33:16 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/fibonacci/</guid>
      <description>Один из классических рекурсивных алгоритмов. Последовательность чисел, где каждое последующее - сумма двух предыдущих.
fibonacci
1 2 3 4 5 6 7 8 9 10 11 12  // O(n) time | O(1) space fun getNthFibonacci(n: Int): Int { val lastTwo = mutableListOf(0, 1) repeat(n - 2) { val next = lastTwo.sum() lastTwo[0] = lastTwo[1] lastTwo[1] = next } return if (n &amp;gt; 1) lastTwo[1] else lastTwo[0] }   </description>
    </item>
    
    <item>
      <title>Insertion Sort</title>
      <link>https://solairerove.github.io/post/insertion-sort/</link>
      <pubDate>Mon, 01 Mar 2021 16:55:11 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/insertion-sort/</guid>
      <description>Один из алгоритмов сортировки. На каждом шаге вставляет на свое место элемент в отсортированный подмассив.
insertion sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // O(n^2) time | O(1) space fun insertionSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 1 until n) { for (j in i downTo 0) { if (j &amp;gt; 0 &amp;amp;&amp;amp; arr[j] &amp;lt; arr[j - 1]) { swap(arr, j, j - 1) } } } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp }   </description>
    </item>
    
    <item>
      <title>Bubble Sort</title>
      <link>https://solairerove.github.io/post/bubble-sort/</link>
      <pubDate>Mon, 01 Mar 2021 14:33:33 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/bubble-sort/</guid>
      <description>Один из не эффективных алгоритмов сортировки, кроме случая, когда коллекция обратно отсортирована. На каждом шаге проталкивает самый большой элемент в конец списка.
bubble sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // O(n^2) time | O(1) space fun bubbleSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 0 until n) { for (j in 0 until (n - i - 1)) { if (arr[j + 1] &amp;lt; arr[j]) { swap(arr, j + 1, j) } } } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp }   </description>
    </item>
    
    <item>
      <title>Selection Sort</title>
      <link>https://solairerove.github.io/post/selection-sort/</link>
      <pubDate>Mon, 01 Mar 2021 13:40:33 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/selection-sort/</guid>
      <description>Один из не эффективных алгоритмов сортировки. На каждом шаге находит минимальный элемент и меняет местами с текущим.
selection sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // O(n^2) time | O(1) space fun selectionSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 0 until n) { var min = i for (j in (i + 1) until n) { if (arr[j] &amp;lt; arr[min]) { min = j } } swap(arr, i, min) } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp }   </description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://solairerove.github.io/post/binary-search/</link>
      <pubDate>Thu, 25 Feb 2021 17:32:26 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/binary-search/</guid>
      <description>Бинарный поиск - алгоритм, на вход которого подается отсортированный список элементов. Если искомый элемент присутствует, то бинарный поиск возвращает его позицию.
Предположим, что вы загадали число от 1 до 100. При каждой попытке угадать я буду давать один из трех ответов: много, мало и угадал. Можно перебирать все вариант подряд: 1, 2, 3, 4. А можно исключить сразу половину чисел на каждом шаге: 50, 75, 63.
binary search
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // O(log(n)) time | O(1) space private fun binarySearch(items: List&amp;lt;Int&amp;gt;, item: Int): Int { // храним границы части списка, в которой выполняется поиск  var low = 0 var high = items.</description>
    </item>
    
  </channel>
</rss>
