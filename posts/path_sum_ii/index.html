<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>113. Path Sum II - Headstone lamp - leetcode grind (60)</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="dfs," />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="113. Path Sum II" />
<meta property="og:description" content="dfs," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://solairerove.github.io/posts/path_sum_ii/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-11-16T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="113. Path Sum II"/>
<meta name="twitter:description" content="dfs,"/>
<script src="https://solairerove.github.io/js/feather.min.js"></script>
	
	
        <link href="https://solairerove.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://solairerove.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://solairerove.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://solairerove.github.io/">Headstone lamp - leetcode grind (60)</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">113. Path Sum II</h1>
			<div class="meta">Posted on Nov 16, 2023</div>
		</div>
		

		<section class="body">
			<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#080;font-style:italic"># O(n) time || O(max(n, log(n)) space</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">path_sum_rec</span>(self, root: Optional[TreeNode], target_sum: <span style="color:#a2f">int</span>) <span style="color:#666">-&gt;</span> List[List[<span style="color:#a2f">int</span>]]:
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f;font-weight:bold">not</span> root:
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    res <span style="color:#666">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">dfs</span>(node, curr_sum, curr_path):
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f;font-weight:bold">not</span> node:
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        curr_sum <span style="color:#666">+=</span> node<span style="color:#666">.</span>val
</span></span><span style="display:flex;"><span>        curr_path<span style="color:#666">.</span>append(node<span style="color:#666">.</span>val)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f;font-weight:bold">not</span> node<span style="color:#666">.</span>left <span style="color:#a2f;font-weight:bold">and</span> <span style="color:#a2f;font-weight:bold">not</span> node<span style="color:#666">.</span>right <span style="color:#a2f;font-weight:bold">and</span> curr_sum <span style="color:#666">==</span> target_sum:
</span></span><span style="display:flex;"><span>            res<span style="color:#666">.</span>append(<span style="color:#a2f">list</span>(curr_path))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dfs(node<span style="color:#666">.</span>left, curr_sum, curr_path)
</span></span><span style="display:flex;"><span>        dfs(node<span style="color:#666">.</span>right, curr_sum, curr_path)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        curr_path<span style="color:#666">.</span>pop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dfs(root, <span style="color:#666">0</span>, [])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#080;font-style:italic"># O(n) time || O(max(n, log(n)) space</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">path_sum_dfs</span>(self, root: Optional[TreeNode], target_sum: <span style="color:#a2f">int</span>) <span style="color:#666">-&gt;</span> List[List[<span style="color:#a2f">int</span>]]:
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f;font-weight:bold">not</span> root:
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    res <span style="color:#666">=</span> []
</span></span><span style="display:flex;"><span>    stack <span style="color:#666">=</span> [(root, root<span style="color:#666">.</span>val, [root<span style="color:#666">.</span>val])]
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> stack:
</span></span><span style="display:flex;"><span>        node, curr_sum, curr_path <span style="color:#666">=</span> stack<span style="color:#666">.</span>pop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f;font-weight:bold">not</span> node<span style="color:#666">.</span>left <span style="color:#a2f;font-weight:bold">and</span> <span style="color:#a2f;font-weight:bold">not</span> node<span style="color:#666">.</span>right <span style="color:#a2f;font-weight:bold">and</span> curr_sum <span style="color:#666">==</span> target_sum:
</span></span><span style="display:flex;"><span>            res<span style="color:#666">.</span>append(curr_path)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> node<span style="color:#666">.</span>left:
</span></span><span style="display:flex;"><span>            stack<span style="color:#666">.</span>append((node<span style="color:#666">.</span>left, curr_sum <span style="color:#666">+</span> node<span style="color:#666">.</span>left<span style="color:#666">.</span>val, curr_path <span style="color:#666">+</span> [node<span style="color:#666">.</span>left<span style="color:#666">.</span>val]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> node<span style="color:#666">.</span>right:
</span></span><span style="display:flex;"><span>            stack<span style="color:#666">.</span>append((node<span style="color:#666">.</span>right, curr_sum <span style="color:#666">+</span> node<span style="color:#666">.</span>right<span style="color:#666">.</span>val, curr_path <span style="color:#666">+</span> [node<span style="color:#666">.</span>right<span style="color:#666">.</span>val]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res
</span></span></code></pre></div><p>To solve this problem, we can use a Depth-First Search (DFS) approach. We&rsquo;ll traverse the tree from the root to each
leaf, maintaining the current path and the sum of node values along the path. Whenever we reach a leaf node, we&rsquo;ll check
if the sum equals <code>targetSum</code>, and if it does, we&rsquo;ll add the current path to our list of valid paths.</p>
<ol>
<li>
<p>Recursive DFS Function:</p>
<ul>
<li>The <code>dfs</code> function takes a <code>node</code>, the <code>current_sum</code> of the path from the root to this node, and the
current <code>path</code> (a list of node values).</li>
<li>If the node is <code>None</code>, we return as there&rsquo;s nothing to process.</li>
<li>The node&rsquo;s value is added to both the <code>current_sum</code> and the <code>path</code>.</li>
<li>If the node is a leaf (no left or right child) and <code>current_sum</code> equals <code>targetSum</code>, we add a copy of the current
path to the result list.</li>
</ul>
</li>
<li>
<p>Exploring Left and Right Subtrees:</p>
<ul>
<li>Recursively call <code>dfs</code> for the left and right children of the current node, passing along the updated sum and
path.</li>
</ul>
</li>
<li>
<p>Backtracking:</p>
<ul>
<li>After exploring a node (including its subtrees), we pop its value from the path to backtrack. This step is crucial
as it ensures that the path list correctly represents the path from the root to the current node in the DFS.</li>
</ul>
</li>
<li>
<p>Storing and Returning Results:</p>
<ul>
<li>The <code>result</code> list accumulates all the valid paths. This list is returned at the end.</li>
</ul>
</li>
</ol>
<p>This approach ensures that all root-to-leaf paths are explored and the correct paths that sum to <code>targetSum</code> are
recorded. The use of backtracking is key to manage the current path state as we traverse the tree.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/trees">trees</a></li>
					
					<li><a href="/tags/dfs-bfs">dfs-bfs</a></li>
					
					<li><a href="/tags/medium">medium</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/solairerove" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2024  © solairerove |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
