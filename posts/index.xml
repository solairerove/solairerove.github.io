<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Headstone lamp - leetcode grind</title>
    <link>https://solairerove.github.io/posts/</link>
    <description>Recent content in Posts on Headstone lamp - leetcode grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Tue, 24 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>15. 3Sum</title>
      <link>https://solairerove.github.io/posts/three_sum/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/three_sum/</guid>
      <description># O(n^2) time || O(1) space def three_sum(self, nums: List[int]) -&amp;gt; List[List[int]]: nums.sort() triplets = [] for i in range(len(nums) - 2): if i &amp;gt; 0 and nums[i] == nums[i - 1]: continue low, high = i + 1, len(nums) - 1 while low &amp;lt; high: sum_ = nums[i] + nums[low] + nums[high] if sum_ == 0: triplets.append([nums[i], nums[low], nums[high]]) low, high = low + 1, high - 1 while low &amp;lt; high and nums[low] == nums[low - 1]: low += 1 while low &amp;lt; high and nums[high] == nums[high + 1]: high -= 1 elif sum_ &amp;lt; 0: low += 1 else: high -= 1 return triplets You can solve this problem using a sorting-based approach combined with the two-pointer technique.</description>
    </item>
    
    <item>
      <title>18. 4Sum</title>
      <link>https://solairerove.github.io/posts/four_sum/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/four_sum/</guid>
      <description># O(n^3) time || O(1) space def four_sum(self, nums: List[int], target: int) -&amp;gt; List[List[int]]: nums.sort() res, n = [], len(nums) for i in range(n - 3): if i &amp;gt; 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j &amp;gt; i + 1 and nums[j] == nums[j - 1]: continue low, high = j + 1, n - 1 while low &amp;lt; high: sum_ = nums[i] + nums[j] + nums[low] + nums[high] if sum_ == target: res.</description>
    </item>
    
    <item>
      <title>242. Valid Anagram</title>
      <link>https://solairerove.github.io/posts/valid_anagram/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/valid_anagram/</guid>
      <description># O(n) time || O(1) space def is_anagram(self, s: str, t: str) -&amp;gt; bool: if len(s) != len(t): return False cnt = [0] * 26 for i in range(len(s)): cnt[ord(s[i]) - ord(&amp;#39;a&amp;#39;)] += 1 cnt[ord(t[i]) - ord(&amp;#39;a&amp;#39;)] -= 1 return max(cnt) == 0 # O(n) time || O(n) space def is_anagram_counter(self, s: str, t: str) -&amp;gt; bool: return collections.Counter(s) == collections.Counter(t) Efficient method is to count the occurrences of each character in both strings and then compare the counts.</description>
    </item>
    
    <item>
      <title>49. Group Anagrams</title>
      <link>https://solairerove.github.io/posts/group_anagrams/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/group_anagrams/</guid>
      <description># O(w * n * log(n)) time || O(wn) space def group_anagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dic = collections.defaultdict(list) for s in strs: dic[tuple(sorted(s))].append(s) return list(dic.values()) # O(n * m) time || O(n * m) space, # m - number of strings # n - average number of letters def group_anagrams_count_approach(self, strs: List[str]) -&amp;gt; List[List[str]]: def get_key(s): cnt = [0] * 26 for c in s: cnt[ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 return tuple(cnt) dic = collections.</description>
    </item>
    
    <item>
      <title>1. Two Sum</title>
      <link>https://solairerove.github.io/posts/two_sum/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/two_sum/</guid>
      <description># O(n) time || O(n) space def two_sum(self, nums: List[int], target: int) -&amp;gt; List[int]: dic = {} for i, num in enumerate(nums): if target - num in dic: return [dic[target - num], i] dic[num] = i In this solution, we use a dictionary dic to store the numbers encountered so far along with their indices. As we iterate through the array, we check if the complement (target - num) exists in the num_map dictionary.</description>
    </item>
    
    <item>
      <title>1011. Capacity To Ship Packages Within D Days</title>
      <link>https://solairerove.github.io/posts/capacity_to_ship_packages_within_d_days/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/capacity_to_ship_packages_within_d_days/</guid>
      <description># O(n * log(n)) time || O(1) space def ship_within_days(self, weights: List[int], days: int) -&amp;gt; int: low, high = max(weights), sum(weights) while low &amp;lt;= high: mid = low + (high - low) // 2 days_required, curr_weight = 1, 0 for weight in weights: if curr_weight + weight &amp;lt;= mid: curr_weight += weight else: days_required, curr_weight = days_required + 1, weight if days_required &amp;lt;= days: high = mid - 1 else: low = mid + 1 return low Determine the search space: The minimum possible weight capacity of the ship would be the maximum weight among all the packages, and the maximum possible weight capacity of the ship would be the sum of all the package weights.</description>
    </item>
    
    <item>
      <title>136. Single Number</title>
      <link>https://solairerove.github.io/posts/single_number/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/single_number/</guid>
      <description># O(n) time || O(1) space def single_number(self, nums: List[int]) -&amp;gt; int: res = 0 for n in nums: res ^= n return res # O(n) time || O(1) space def single_number_reduce(self, nums: List[int]) -&amp;gt; int: return functools.reduce(lambda x, y: x ^ y, nums) To find the element that appears only once in the array with a linear runtime complexity and constant extra space, you can utilize the XOR operator.</description>
    </item>
    
    <item>
      <title>875. Koko Eating Bananas</title>
      <link>https://solairerove.github.io/posts/koko_eating_bananas/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/koko_eating_bananas/</guid>
      <description># O(n * log(max(p)) time || O(1) space def min_eating_speed(self, piles: List[int], h: int) -&amp;gt; int: low, high = 1, max(piles) while low &amp;lt; high: hours, mid = 0, low + (high - low) // 2 if sum((math.ceil(pile / mid)) for pile in piles) &amp;lt;= h: high = mid else: low = mid + 1 return high if the current speed is workable, the minimum workable speed should be on its left inclusively.</description>
    </item>
    
    <item>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link>https://solairerove.github.io/posts/find_minimum_in_rotated_sorted_array/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/find_minimum_in_rotated_sorted_array/</guid>
      <description># O(log(n)) time || O(1) space def find_min(self, nums: List[int]) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt; high: mid = low + (high - low) // 2 if nums[mid] &amp;gt; nums[high]: low = mid + 1 else: high = mid return nums[high] array might be offset but still is sorted. use binary search, take in consider in which part to have a search. if mid element bigger than last one, low border is mid + 1</description>
    </item>
    
    <item>
      <title>33. Search in Rotated Sorted Array</title>
      <link>https://solairerove.github.io/posts/search_in_rotated_sorted_array/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_in_rotated_sorted_array/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid if nums[low] &amp;lt;= nums[mid]: if nums[low] &amp;lt;= target &amp;lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &amp;lt;= target &amp;lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 array might be offset but still is sorted.</description>
    </item>
    
    <item>
      <title>81. Search in Rotated Sorted Array II</title>
      <link>https://solairerove.github.io/posts/search_in_rotated_sorted_array_ii/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_in_rotated_sorted_array_ii/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; bool: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return True while low &amp;lt; mid and nums[low] == nums[mid]: low += 1 if nums[low] &amp;lt;= nums[mid]: if nums[low] &amp;lt;= target &amp;lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &amp;lt;= target &amp;lt;= nums[high]: low = mid + 1 else: high = mid - 1 return False array might be offset but still is sorted.</description>
    </item>
    
    <item>
      <title>278. First Bad Version</title>
      <link>https://solairerove.github.io/posts/first_bad_version/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/first_bad_version/</guid>
      <description># The isBadVersion API is already defined for you. # def isBadVersion(version: int) -&amp;gt; bool: # O(log(n)) time || O(1) space def first_bad_version(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 if isBadVersion(mid): high = mid - 1 else: low = mid + 1 return low you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>374. Guess Number Higher or Lower</title>
      <link>https://solairerove.github.io/posts/guess_number_higher_or_lower/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/guess_number_higher_or_lower/</guid>
      <description># @param num, your guess # @return -1 if num is higher than the picked number # 1 if num is lower than the picked number # otherwise return 0 # def guess(num: int) -&amp;gt; int: # O(log(n)) time || O(1) space def guess_number(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 cmp = guess(mid) if cmp == 0: return mid elif cmp == -1: high = mid - 1 else: low = mid + 1 you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>704. Binary Search</title>
      <link>https://solairerove.github.io/posts/binary_search/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/binary_search/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid elif target &amp;lt; nums[mid]: high = mid - 1 else: low = mid + 1 return -1 classic default binary search. have two pointers as search border. decrease search borders two times on each iteration like you&amp;rsquo;re trying to find word in dictionary book.</description>
    </item>
    
    <item>
      <title>74. Search a 2D Matrix</title>
      <link>https://solairerove.github.io/posts/search_a_2d_matrix/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_a_2d_matrix/</guid>
      <description># O(log(m * n)) time || O(1) space def search_matrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 mid_row, mid_col = divmod(mid, cols) if target == matrix[mid_row][mid_col]: return True elif target &amp;lt; matrix[mid_row][mid_col]: high = mid - 1 else: low = mid + 1 return False to get midpoint in the matrix, we use the divmod function with mid and cols</description>
    </item>
    
    <item>
      <title>844. Backspace String Compare</title>
      <link>https://solairerove.github.io/posts/backspace_string_compare/</link>
      <pubDate>Thu, 19 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/backspace_string_compare/</guid>
      <description># O(n + m) time || O(1) space def backspace_compare_two_pointers(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): skip = 0 for c in reversed(to_trim): if c == &amp;#39;#&amp;#39;: skip += 1 elif skip: skip -= 1 else: yield c return all(a == b for a, b in itertools.zip_longest(trim(s), trim(t))) # O(n + m) time || O(n + m) space def backspace_compare_stack(self, s: str, t: str) -&amp;gt; bool: def trim(line): stack = [] for c in line: if c !</description>
    </item>
    
    <item>
      <title>141. Linked List Cycle</title>
      <link>https://solairerove.github.io/posts/linked_list_cycle/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/linked_list_cycle/</guid>
      <description># O(n) time || O(1) space def has_cycle(self, head: Optional[ListNode]) -&amp;gt; bool: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: return True return False Floyd&#39;s Cycle Finding Algorithm by considering two pointers at different speed. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</description>
    </item>
    
    <item>
      <title>2. Add Two Numbers</title>
      <link>https://solairerove.github.io/posts/add_two_numbers/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/add_two_numbers/</guid>
      <description># O(max(n, m)) time || O(1) space def add_two_numbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: sentinel = ListNode() prev = sentinel hold = 0 while l1 or l2: curr_sum = 0 if l1: curr_sum, l1 = curr_sum + l1.val, l1.next if l2: curr_sum, l2 = curr_sum + l2.val, l2.next curr_sum += hold prev.next, hold = ListNode(curr_sum % 10), curr_sum // 10 prev = prev.next if hold: prev.next = ListNode(hold) return sentinel.</description>
    </item>
    
    <item>
      <title>206. Reverse Linked List</title>
      <link>https://solairerove.github.io/posts/reverse_linked_list/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/reverse_linked_list/</guid>
      <description># O(n) time || O(1) space def reverse_list(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: prev, curr = None, head while curr: curr.next, prev, curr = prev, curr, curr.next return prev traverse linked list using curr pointer. relink curr.next to prev each step on iteration. return the prev as head of reversed list</description>
    </item>
    
    <item>
      <title>23. Merge k Sorted Lists</title>
      <link>https://solairerove.github.io/posts/merge_k_sorted_lists/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/merge_k_sorted_lists/</guid>
      <description># O(n * log(k)) time | O(1) space # n - is total number of nodes # k - is number of linked lists def merge_k_lists(self, lists: List[Optional[ListNode]]) -&amp;gt; Optional[ListNode]: if not lists: return None if len(lists) == 1: return lists[0] interval = 1 while interval &amp;lt; len(lists): for i in range(0, len(lists) - interval, interval * 2): lists[i] = self.merge(lists[i], lists[i + interval]) interval *= 2 return lists[0] # 21.</description>
    </item>
    
    <item>
      <title>876. Middle of the Linked List</title>
      <link>https://solairerove.github.io/posts/middle_of_the_linked_list/</link>
      <pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/middle_of_the_linked_list/</guid>
      <description># O(n) time || O(1) space def middle_node(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: if not head.next: return head slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow fast pointer traverse two times faster than slow, so when fast is done, slow is in middle of lined list</description>
    </item>
    
    <item>
      <title>11. Container With Most Water</title>
      <link>https://solairerove.github.io/posts/container_with_most_water/</link>
      <pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/container_with_most_water/</guid>
      <description># O(n) time || O(1) space def max_area(self, height: List[int]) -&amp;gt; int: area, low, high = 0, 0, len(height) - 1 while low &amp;lt; high: area = max(area, min(height[low], height[high]) * (high - low)) if height[low] &amp;lt;= height[high]: low += 1 else: high -= 1 return area </description>
    </item>
    
  </channel>
</rss>
