<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Headstone lamp - leetcode grind</title>
    <link>https://solairerove.github.io/posts/</link>
    <description>Recent content in Posts on Headstone lamp - leetcode grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Fri, 20 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>278. First Bad Version</title>
      <link>https://solairerove.github.io/posts/first_bad_version/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/first_bad_version/</guid>
      <description># The isBadVersion API is already defined for you. # def isBadVersion(version: int) -&amp;gt; bool: # O(log(n)) time || O(1) space def first_bad_version(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 if isBadVersion(mid): high = mid - 1 else: low = mid + 1 return low you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>374. Guess Number Higher or Lower</title>
      <link>https://solairerove.github.io/posts/guess_number_higher_or_lower/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/guess_number_higher_or_lower/</guid>
      <description># @param num, your guess # @return -1 if num is higher than the picked number # 1 if num is lower than the picked number # otherwise return 0 # def guess(num: int) -&amp;gt; int: # O(log(n)) time || O(1) space def guess_number(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 cmp = guess(mid) if cmp == 0: return mid elif cmp == -1: high = mid - 1 else: low = mid + 1 you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>704. Binary Search</title>
      <link>https://solairerove.github.io/posts/binary_search/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/binary_search/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid elif target &amp;lt; nums[mid]: high = mid - 1 else: low = mid + 1 return -1 classic default binary search. have two pointers as search border. decrease search borders two times on each iteration like you&amp;rsquo;re trying to find word in dictionary book.</description>
    </item>
    
    <item>
      <title>844. Backspace String Compare</title>
      <link>https://solairerove.github.io/posts/backspace_string_compare/</link>
      <pubDate>Thu, 19 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/backspace_string_compare/</guid>
      <description># O(n + m) time || O(1) space def backspace_compare_two_pointers(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): skip = 0 for c in reversed(to_trim): if c == &amp;#39;#&amp;#39;: skip += 1 elif skip: skip -= 1 else: yield c return all(a == b for a, b in itertools.zip_longest(trim(s), trim(t))) # O(n + m) time || O(n + m) space def backspace_compare_stack(self, s: str, t: str) -&amp;gt; bool: def trim(line): stack = [] for c in line: if c !</description>
    </item>
    
    <item>
      <title>141. Linked List Cycle</title>
      <link>https://solairerove.github.io/posts/linked_list_cycle/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/linked_list_cycle/</guid>
      <description># O(n) time || O(1) space def has_cycle(self, head: Optional[ListNode]) -&amp;gt; bool: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: return True return False Floyd&#39;s Cycle Finding Algorithm by considering two pointers at different speed. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</description>
    </item>
    
    <item>
      <title>2. Add Two Numbers</title>
      <link>https://solairerove.github.io/posts/add_two_numbers/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/add_two_numbers/</guid>
      <description># O(max(n, m)) time || O(1) space def add_two_numbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: sentinel = ListNode() prev = sentinel hold = 0 while l1 or l2: curr_sum = 0 if l1: curr_sum, l1 = curr_sum + l1.val, l1.next if l2: curr_sum, l2 = curr_sum + l2.val, l2.next curr_sum += hold prev.next, hold = ListNode(curr_sum % 10), curr_sum // 10 prev = prev.next if hold: prev.next = ListNode(hold) return sentinel.</description>
    </item>
    
    <item>
      <title>206. Reverse Linked List</title>
      <link>https://solairerove.github.io/posts/reverse_linked_list/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/reverse_linked_list/</guid>
      <description># O(n) time || O(1) space def reverse_list(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: prev, curr = None, head while curr: curr.next, prev, curr = prev, curr, curr.next return prev traverse linked list using curr pointer. relink curr.next to prev each step on iteration. return the prev as head of reversed list</description>
    </item>
    
    <item>
      <title>23. Merge k Sorted Lists</title>
      <link>https://solairerove.github.io/posts/merge_k_sorted_lists/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/merge_k_sorted_lists/</guid>
      <description># O(n * log(k)) time | O(1) space # n - is total number of nodes # k - is number of linked lists def merge_k_lists(self, lists: List[Optional[ListNode]]) -&amp;gt; Optional[ListNode]: if not lists: return None if len(lists) == 1: return lists[0] interval = 1 while interval &amp;lt; len(lists): for i in range(0, len(lists) - interval, interval * 2): lists[i] = self.merge(lists[i], lists[i + interval]) interval *= 2 return lists[0] # 21.</description>
    </item>
    
    <item>
      <title>876. Middle of the Linked List</title>
      <link>https://solairerove.github.io/posts/middle_of_the_linked_list/</link>
      <pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/middle_of_the_linked_list/</guid>
      <description># O(n) time || O(1) space def middle_node(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: if not head.next: return head slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow fast pointer traverse two times faster than slow, so when fast is done, slow is in middle of lined list</description>
    </item>
    
    <item>
      <title>11. Container With Most Water</title>
      <link>https://solairerove.github.io/posts/container_with_most_water/</link>
      <pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/container_with_most_water/</guid>
      <description># O(n) time || O(1) space def max_area(self, height: List[int]) -&amp;gt; int: area, low, high = 0, 0, len(height) - 1 while low &amp;lt; high: area = max(area, min(height[low], height[high]) * (high - low)) if height[low] &amp;lt;= height[high]: low += 1 else: high -= 1 return area </description>
    </item>
    
  </channel>
</rss>
