<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hugo Site</title>
    <link>https://solairerove.github.io/posts/</link>
    <description>Recent content in Posts on Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 31 Mar 2021 23:10:38 +0300</lastBuildDate><atom:link href="https://solairerove.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Inversions</title>
      <link>https://solairerove.github.io/posts/inversions/</link>
      <pubDate>Wed, 31 Mar 2021 23:10:38 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/inversions/</guid>
      <description>Вытекающая задача из сортировки слиянием. \
3.2 Подсчет инверсий
inversions
// O(nlog(n)) time | O(n) space fun count(arr: MutableList&amp;lt;Int&amp;gt;): Long { val n = arr.size val b = MutableList(n) { i -&amp;gt; i } val aux = MutableList(n) { i -&amp;gt; i } for (i in 0 until n) { b[i] = arr[i] } return count(arr, b, aux, 0, n - 1) } fun count(arr: MutableList&amp;lt;Int&amp;gt;, b: MutableList&amp;lt;Int&amp;gt;, aux: MutableList&amp;lt;Int&amp;gt;, low: Int, high: Int): Long { var inversions = 0L if (high &amp;lt;= low) { return 0 } val mid = low + (high - low) / 2 inversions += count(arr, b, aux, low, mid) inversions += count(arr, b, aux, mid + 1, high) inversions += merge(b, aux, low, mid, high) return inversions } fun merge(arr: MutableList&amp;lt;Int&amp;gt;, aux: MutableList&amp;lt;Int&amp;gt;, low: Int, mid: Int, high: Int): Long { var inversions = 0L for (k in low.</description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://solairerove.github.io/posts/merge-sort/</link>
      <pubDate>Fri, 26 Mar 2021 17:28:02 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/merge-sort/</guid>
      <description>Классический эффективный алгоритм сортировки divide and conquer.
Разделяем массив на подмассивы до подмассивов размером 1 и
собираем их в отсортированные подмассивы.
Почему O(nlog(n)).
Потому что у нас всего nlog(n) операций, которые сами по себе O(n).
princeton mergesort
merge sort
// O(nlog(n)) time | O(n) space fun mergeSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size val aux = MutableList(n) { i -&amp;gt; i } mergeSort(arr, aux, 0, n - 1) } fun mergeSort(arr: MutableList&amp;lt;Int&amp;gt;, aux: MutableList&amp;lt;Int&amp;gt;, low: Int, high: Int) { if (high &amp;lt;= low) { return } val mid = low + (high - low) / 2 mergeSort(arr, aux, low, mid) mergeSort(arr, aux, mid + 1, high) merge(arr, aux, low, mid, high) } fun merge(arr: MutableList&amp;lt;Int&amp;gt;, aux: MutableList&amp;lt;Int&amp;gt;, low: Int, mid: Int, high: Int) { var i = low var j = mid + 1 for (k in low.</description>
    </item>
    
    <item>
      <title>Min Heap</title>
      <link>https://solairerove.github.io/posts/min-heap/</link>
      <pubDate>Thu, 11 Mar 2021 20:27:42 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/min-heap/</guid>
      <description>Main methods:
 build heap sift down sift up insert remove  Node:
 current node -&amp;gt; i child one -&amp;gt; (2 * i) + 1 child two -&amp;gt; (2 * i) + 2 parent node -&amp;gt; (i - 1) / 2  Transform array to heap (heapify)
 foreach parent sink  min heap
Priority Queues
stepik max heap
class MinHeap(arr: MutableList&amp;lt;Int&amp;gt;) { private var heap: MutableList&amp;lt;Int&amp;gt; = arr init { val n = arr.</description>
    </item>
    
    <item>
      <title>Heap Sort</title>
      <link>https://solairerove.github.io/posts/heap-sort/</link>
      <pubDate>Tue, 09 Mar 2021 17:45:39 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/heap-sort/</guid>
      <description>build heap from array and n time get min element. (naive heap sort)
heap sort
// O(nlogn) time | O(1) space fun heapSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (k in n / 2 downTo 1) { sink(arr, k, n) } var k = n while (k &amp;gt; 1) { swap(arr, 1, k--) sink(arr, 1, k) } } fun sink(arr: MutableList&amp;lt;Int&amp;gt;, k: Int, n: Int) { var idx = k while (2 * idx &amp;lt;= n) { var j = 2 * idx if (j &amp;lt; n &amp;amp;&amp;amp; less(arr, j, j + 1)) j++ if (!</description>
    </item>
    
    <item>
      <title>Minimum Waiting Time</title>
      <link>https://solairerove.github.io/posts/minimum-waiting-time/</link>
      <pubDate>Mon, 08 Mar 2021 17:27:29 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/minimum-waiting-time/</guid>
      <description>Given non-empty array of positive int, that define time to execute.
Only one query can be executed at time, but in any order.
Get minimal waiting time to execute all queries.
Solid step is ascending sort.
9 6 5 2 3 1 -&amp;gt; 1 2 3 5 6 9 -&amp;gt; 0 + 1 + (1 + 2) + (1 + 2 + 3) + (1 + 2 + 3 + 5) + (1 + 2 + 3 + 5 + 6) = 38</description>
    </item>
    
    <item>
      <title>Huffman Decode</title>
      <link>https://solairerove.github.io/posts/huffman-decode/</link>
      <pubDate>Sun, 07 Mar 2021 18:25:44 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/huffman-decode/</guid>
      <description>Формулировка задачи
huffman decode
// abacabad fun main() { val dictionary = mapOf( Pair(&amp;#34;0&amp;#34;, &amp;#34;a&amp;#34;), Pair(&amp;#34;10&amp;#34;, &amp;#34;b&amp;#34;), Pair(&amp;#34;110&amp;#34;, &amp;#34;c&amp;#34;), Pair(&amp;#34;111&amp;#34;, &amp;#34;d&amp;#34;) ) val s = &amp;#34;01001100100111&amp;#34; val stringBuilder = StringBuilder() var i = 0 while (i &amp;lt; s.length) { var isCodeFound = false var code = s[i].toString() while (!isCodeFound) { if (dictionary.containsKey(code)) { stringBuilder.append(dictionary[code]) isCodeFound = true } else { code = code.plus(s[++i].toString()) isCodeFound = false } } i++ } print(stringBuilder.</description>
    </item>
    
    <item>
      <title>Naive Huffman Encode</title>
      <link>https://solairerove.github.io/posts/naive-huffman-encode/</link>
      <pubDate>Sun, 07 Mar 2021 15:55:23 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/naive-huffman-encode/</guid>
      <description>Формулировка задачи
naive huffman encode
/** * abacabad * 4 14 * a: 0 * b: 10 * c: 110 * d: 111 * 01001100100111 */ fun main() { val s = &amp;#34;abacabad&amp;#34; val letterToFreq = getLetterToFrequency(s = s) val letterWeightStack = getLetterWeightStack(letterToFreq = letterToFreq) val huffmanResult = huffman(letterWeightStack = letterWeightStack) val dictionary = getDictionary(huffmanResult = huffmanResult) val encodedString = encodeString(stringToEncode = s, dictionary = dictionary) println(&amp;#34;${dictionary.keys.size}${encodedString.length}&amp;#34;) dictionary.forEach { println(&amp;#34;${it.key}: ${it.</description>
    </item>
    
    <item>
      <title>Number Partition</title>
      <link>https://solairerove.github.io/posts/number-partition/</link>
      <pubDate>Thu, 04 Mar 2021 18:55:57 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/number-partition/</guid>
      <description>Формулировка задачи
number partition
fun main() { var n = 6 val res = mutableListOf&amp;lt;Int&amp;gt;() for (i in 1..n) { if (n - i &amp;gt;= i + 1) { res.add(i) } else { res.add(n) break } n -= i } print(&amp;#34;${res.size}\n&amp;#34;) res.forEach { print(&amp;#34;$it&amp;#34;) } } </description>
    </item>
    
    <item>
      <title>Knapsack Problem</title>
      <link>https://solairerove.github.io/posts/knapsack-problem/</link>
      <pubDate>Thu, 04 Mar 2021 17:58:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/knapsack-problem/</guid>
      <description>Формулировка задачи
knapsack problem
import java.text.DecimalFormat fun main() { var backPackSize = 50 val items = mutableListOf( Item(worth = 60, volume = 20, worthPerVolume = (60 / 20).toDouble()), Item(worth = 100, volume = 50, worthPerVolume = (100 / 50).toDouble()), Item(worth = 120, volume = 30, worthPerVolume = (120 / 30).toDouble()) ) items.sortByDescending { it.worthPerVolume } var res = 0.0 for (item in items) { if (item.volume &amp;lt; backPackSize) { res += item.</description>
    </item>
    
    <item>
      <title>Segments Covering by Unit</title>
      <link>https://solairerove.github.io/posts/segments-covering-by-unit/</link>
      <pubDate>Thu, 04 Mar 2021 13:00:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/segments-covering-by-unit/</guid>
      <description>Даны отрезки на прямой. Найти такие точки, которые лежат на всех заданных отрезках. Найденное множество должно быть минимальным по размеру.
Берем все концы отрезков (как левые, так и правые) и сортируем их. Для каждой точки сохраним номер отрезка. Также каким концом его она является (левым или правым). Учтем, что если есть несколько точек с одной координатой, то сначала будут идти левые концы, потом правые.
Заведём коллекцию, в которой будут храниться номера отрезков, рассматриваемых в данный момент.</description>
    </item>
    
    <item>
      <title>Palindrome Check</title>
      <link>https://solairerove.github.io/posts/palindrome-check/</link>
      <pubDate>Wed, 03 Mar 2021 16:56:50 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/palindrome-check/</guid>
      <description>Палиндром - строка, которая одинаково читается в обоих направлениях.
palindrome check
// O(n) time | O(1) space fun isPalindrome(s: String): Boolean { for (i in s.indices) { if (s[i] != s[s.length - 1 - i]) { return false } } return true } </description>
    </item>
    
    <item>
      <title>Highest Common Factor</title>
      <link>https://solairerove.github.io/posts/highest-common-factor/</link>
      <pubDate>Tue, 02 Mar 2021 13:27:30 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/highest-common-factor/</guid>
      <description>Рекурсивный вариант алгоритма Евклида для нахождения наибольшего общего делителя.
gcd
fun gcd(p: Int, q: Int): Int { if (q == 0) { return p } val r = p % q return gcd(q, r) } </description>
    </item>
    
    <item>
      <title>Fibonacci</title>
      <link>https://solairerove.github.io/posts/fibonacci/</link>
      <pubDate>Tue, 02 Mar 2021 11:33:16 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/fibonacci/</guid>
      <description>Один из классических рекурсивных алгоритмов. Последовательность чисел, где каждое последующее - сумма двух предыдущих.
fibonacci
// O(n) time | O(1) space fun getNthFibonacci(n: Int): Int { val lastTwo = mutableListOf(0, 1) repeat(n - 2) { val next = lastTwo.sum() lastTwo[0] = lastTwo[1] lastTwo[1] = next } return if (n &amp;gt; 1) lastTwo[1] else lastTwo[0] } </description>
    </item>
    
    <item>
      <title>Insertion Sort</title>
      <link>https://solairerove.github.io/posts/insertion-sort/</link>
      <pubDate>Mon, 01 Mar 2021 16:55:11 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/insertion-sort/</guid>
      <description>Один из алгоритмов сортировки. На каждом шаге вставляет на свое место элемент в отсортированный подмассив.
insertion sort
// O(n^2) time | O(1) space fun insertionSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 1 until n) { for (j in i downTo 0) { if (j &amp;gt; 0 &amp;amp;&amp;amp; arr[j] &amp;lt; arr[j - 1]) { swap(arr, j, j - 1) } } } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp } </description>
    </item>
    
    <item>
      <title>Bubble Sort</title>
      <link>https://solairerove.github.io/posts/bubble-sort/</link>
      <pubDate>Mon, 01 Mar 2021 14:33:33 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/bubble-sort/</guid>
      <description>Один из не эффективных алгоритмов сортировки, кроме случая, когда коллекция обратно отсортирована. На каждом шаге проталкивает самый большой элемент в конец списка.
bubble sort
// O(n^2) time | O(1) space fun bubbleSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 0 until n) { for (j in 0 until (n - i - 1)) { if (arr[j + 1] &amp;lt; arr[j]) { swap(arr, j + 1, j) } } } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp } </description>
    </item>
    
    <item>
      <title>Selection Sort</title>
      <link>https://solairerove.github.io/posts/selection-sort/</link>
      <pubDate>Mon, 01 Mar 2021 13:40:33 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/selection-sort/</guid>
      <description>Один из не эффективных алгоритмов сортировки. На каждом шаге находит минимальный элемент и меняет местами с текущим.
selection sort
// O(n^2) time | O(1) space fun selectionSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 0 until n) { var min = i for (j in (i + 1) until n) { if (arr[j] &amp;lt; arr[min]) { min = j } } swap(arr, i, min) } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp } </description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://solairerove.github.io/posts/binary-search/</link>
      <pubDate>Thu, 25 Feb 2021 17:32:26 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/binary-search/</guid>
      <description>Бинарный поиск - алгоритм, на вход которого подается отсортированный список элементов. Если искомый элемент присутствует, то бинарный поиск возвращает его позицию.
Предположим, что вы загадали число от 1 до 100. При каждой попытке угадать я буду давать один из трех ответов: много, мало и угадал. Можно перебирать все вариант подряд: 1, 2, 3, 4. А можно исключить сразу половину чисел на каждом шаге: 50, 75, 63.
binary search
// O(log(n)) time | O(1) space private fun binarySearch(items: List&amp;lt;Int&amp;gt;, item: Int): Int { // храним границы части списка, в которой выполняется поиск  var low = 0 var high = items.</description>
    </item>
    
  </channel>
</rss>
