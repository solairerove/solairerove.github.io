<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hugo Site</title>
    <link>https://solairerove.github.io/posts/</link>
    <description>Recent content in Posts on Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Mar 2021 18:25:44 +0300</lastBuildDate><atom:link href="https://solairerove.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Huffman Decode</title>
      <link>https://solairerove.github.io/posts/huffman-decode/</link>
      <pubDate>Sun, 07 Mar 2021 18:25:44 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/huffman-decode/</guid>
      <description>Формулировка задачи
huffman decode
// abacabad fun main() { val dictionary = mapOf( Pair(&amp;#34;0&amp;#34;, &amp;#34;a&amp;#34;), Pair(&amp;#34;10&amp;#34;, &amp;#34;b&amp;#34;), Pair(&amp;#34;110&amp;#34;, &amp;#34;c&amp;#34;), Pair(&amp;#34;111&amp;#34;, &amp;#34;d&amp;#34;) ) val s = &amp;#34;01001100100111&amp;#34; val stringBuilder = StringBuilder() var i = 0 while (i &amp;lt; s.length) { var isCodeFound = false var code = s[i].toString() while (!isCodeFound) { if (dictionary.containsKey(code)) { stringBuilder.append(dictionary[code]) isCodeFound = true } else { code = code.plus(s[++i].toString()) isCodeFound = false } } i++ } print(stringBuilder.</description>
    </item>
    
    <item>
      <title>Naive Huffman Encode</title>
      <link>https://solairerove.github.io/posts/naive-huffman-encode/</link>
      <pubDate>Sun, 07 Mar 2021 15:55:23 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/naive-huffman-encode/</guid>
      <description>Формулировка задачи
naive huffman encode
/** * abacabad * 4 14 * a: 0 * b: 10 * c: 110 * d: 111 * 01001100100111 */ fun main() { val s = &amp;#34;abacabad&amp;#34; val letterToFreq = getLetterToFrequency(s = s) val letterWeightStack = getLetterWeightStack(letterToFreq = letterToFreq) val huffmanResult = huffman(letterWeightStack = letterWeightStack) val dictionary = getDictionary(huffmanResult = huffmanResult) val encodedString = encodeString(stringToEncode = s, dictionary = dictionary) println(&amp;#34;${dictionary.keys.size}${encodedString.length}&amp;#34;) dictionary.forEach { println(&amp;#34;${it.key}: ${it.</description>
    </item>
    
    <item>
      <title>Number Partition</title>
      <link>https://solairerove.github.io/posts/number-partition/</link>
      <pubDate>Thu, 04 Mar 2021 18:55:57 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/number-partition/</guid>
      <description>Формулировка задачи
number partition
fun main() { var n = 6 val res = mutableListOf&amp;lt;Int&amp;gt;() for (i in 1..n) { if (n - i &amp;gt;= i + 1) { res.add(i) } else { res.add(n) break } n -= i } print(&amp;#34;${res.size}\n&amp;#34;) res.forEach { print(&amp;#34;$it&amp;#34;) } } </description>
    </item>
    
    <item>
      <title>Knapsack Problem</title>
      <link>https://solairerove.github.io/posts/knapsack-problem/</link>
      <pubDate>Thu, 04 Mar 2021 17:58:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/knapsack-problem/</guid>
      <description>Формулировка задачи
knapsack problem
import java.text.DecimalFormat fun main() { var backPackSize = 50 val items = mutableListOf( Item(worth = 60, volume = 20, worthPerVolume = (60 / 20).toDouble()), Item(worth = 100, volume = 50, worthPerVolume = (100 / 50).toDouble()), Item(worth = 120, volume = 30, worthPerVolume = (120 / 30).toDouble()) ) items.sortByDescending { it.worthPerVolume } var res = 0.0 for (item in items) { if (item.volume &amp;lt; backPackSize) { res += item.</description>
    </item>
    
    <item>
      <title>Segments Covering by Unit</title>
      <link>https://solairerove.github.io/posts/segments-covering-by-unit/</link>
      <pubDate>Thu, 04 Mar 2021 13:00:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/segments-covering-by-unit/</guid>
      <description>Даны отрезки на прямой. Найти такие точки, которые лежат на всех заданных отрезках. Найденное множество должно быть минимальным по размеру.
Берем все концы отрезков (как левые, так и правые) и сортируем их. Для каждой точки сохраним номер отрезка. Также каким концом его она является (левым или правым). Учтем, что если есть несколько точек с одной координатой, то сначала будут идти левые концы, потом правые.
Заведём коллекцию, в которой будут храниться номера отрезков, рассматриваемых в данный момент.</description>
    </item>
    
    <item>
      <title>Palindrome Check</title>
      <link>https://solairerove.github.io/posts/palindrome-check/</link>
      <pubDate>Wed, 03 Mar 2021 16:56:50 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/palindrome-check/</guid>
      <description>Палиндром - строка, которая одинаково читается в обоих направлениях.
palindrome check
// O(n) time | O(1) space fun isPalindrome(s: String): Boolean { for (i in s.indices) { if (s[i] != s[s.length - 1 - i]) { return false } } return true } </description>
    </item>
    
    <item>
      <title>Highest Common Factor</title>
      <link>https://solairerove.github.io/posts/highest-common-factor/</link>
      <pubDate>Tue, 02 Mar 2021 13:27:30 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/highest-common-factor/</guid>
      <description>Рекурсивный вариант алгоритма Евклида для нахождения наибольшего общего делителя.
gcd
fun gcd(p: Int, q: Int): Int { if (q == 0) { return p } val r = p % q return gcd(q, r) } </description>
    </item>
    
    <item>
      <title>Fibonacci</title>
      <link>https://solairerove.github.io/posts/fibonacci/</link>
      <pubDate>Tue, 02 Mar 2021 11:33:16 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/fibonacci/</guid>
      <description>Один из классических рекурсивных алгоритмов. Последовательность чисел, где каждое последующее - сумма двух предыдущих.
fibonacci
// O(n) time | O(1) space fun getNthFibonacci(n: Int): Int { val lastTwo = mutableListOf(0, 1) for (cnt in 3..n) { val next = lastTwo.sum() lastTwo[0] = lastTwo[1] lastTwo[1] = next } return if (n &amp;gt; 1) lastTwo[1] else lastTwo[0] } </description>
    </item>
    
    <item>
      <title>Insertion Sort</title>
      <link>https://solairerove.github.io/posts/insertion-sort/</link>
      <pubDate>Mon, 01 Mar 2021 16:55:11 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/insertion-sort/</guid>
      <description>Один из алгоритмов сортировки. На каждом шаге вставляет на свое место элемент в отсортированный подмассив.
insertion sort
// O(n^2) time | O(1) space fun insertionSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 1 until n) { for (j in i downTo 0) { if (j &amp;gt; 0 &amp;amp;&amp;amp; arr[j] &amp;lt; arr[j - 1]) { swap(arr, j, j - 1) } } } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp } </description>
    </item>
    
    <item>
      <title>Bubble Sort</title>
      <link>https://solairerove.github.io/posts/bubble-sort/</link>
      <pubDate>Mon, 01 Mar 2021 14:33:33 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/bubble-sort/</guid>
      <description>Один из не эффективных алгоритмов сортировки, кроме случая, когда коллекция обратно отсортирована. На каждом шаге проталкивает самый большой элемент в конец списка.
bubble sort
// O(n^2) time | O(1) space fun bubbleSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 0 until n) { for (j in 0 until (n - i - 1)) { if (arr[j + 1] &amp;lt; arr[j]) { swap(arr, j + 1, j) } } } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp } </description>
    </item>
    
    <item>
      <title>Selection Sort</title>
      <link>https://solairerove.github.io/posts/selection-sort/</link>
      <pubDate>Mon, 01 Mar 2021 13:40:33 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/selection-sort/</guid>
      <description>Один из не эффективных алгоритмов сортировки. На каждом шаге находит минимальный элемент и меняет местами с текущим.
selection sort
// O(n^2) time | O(1) space fun selectionSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 0 until n) { var min = i for (j in (i + 1) until n) { if (arr[j] &amp;lt; arr[min]) { min = j } } swap(arr, i, min) } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp } </description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://solairerove.github.io/posts/binary-search/</link>
      <pubDate>Thu, 25 Feb 2021 17:32:26 +0300</pubDate>
      
      <guid>https://solairerove.github.io/posts/binary-search/</guid>
      <description>Бинарный поиск - алгоритм, на вход которого подается отсортированный список элементов. Если искомый элемент присутствует, то бинарный поиск возвращает его позицию.
Предположим, что вы загадали число от 1 до 100. При каждой попытке угадать я буду давать один из трех ответов: много, мало и угадал. Можно перебирать все вариант подряд: 1, 2, 3, 4. А можно исключить сразу половину чисел на каждом шаге: 50, 75, 63.
binary search
// O(log(n)) time | O(1) space private fun binarySearch(items: List&amp;lt;Int&amp;gt;, item: Int): Int { // храним границы части списка, в которой выполняется поиск  var low = 0 var high = items.</description>
    </item>
    
  </channel>
</rss>
