<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>110. Balanced Binary Tree - Headstone lamp - leetcode grind (54)</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="dfs, compute height and check for balance" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="110. Balanced Binary Tree" />
<meta property="og:description" content="dfs, compute height and check for balance" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://solairerove.github.io/posts/balanced_binary_tree/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-11-15T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="110. Balanced Binary Tree"/>
<meta name="twitter:description" content="dfs, compute height and check for balance"/>
<script src="https://solairerove.github.io/js/feather.min.js"></script>
	
	
        <link href="https://solairerove.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://solairerove.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://solairerove.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://solairerove.github.io/">Headstone lamp - leetcode grind (54)</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">110. Balanced Binary Tree</h1>
			<div class="meta">Posted on Nov 15, 2023</div>
		</div>
		

		<section class="body">
			<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#080;font-style:italic"># O(n) time || O(n) space</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">is_balanced</span>(self, root: Optional[TreeNode]) <span style="color:#666">-&gt;</span> <span style="color:#a2f">bool</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">dfs</span>(node):
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f;font-weight:bold">not</span> node:
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>, <span style="color:#a2f;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l_height, l_balanced <span style="color:#666">=</span> dfs(node<span style="color:#666">.</span>left)
</span></span><span style="display:flex;"><span>        r_height, r_balanced <span style="color:#666">=</span> dfs(node<span style="color:#666">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">max</span>(l_height, r_height) <span style="color:#666">+</span> <span style="color:#666">1</span>, l_balanced <span style="color:#a2f;font-weight:bold">and</span> r_balanced <span style="color:#a2f;font-weight:bold">and</span> <span style="color:#a2f">abs</span>(l_height <span style="color:#666">-</span> r_height) <span style="color:#666">&lt;=</span> <span style="color:#666">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dfs(root)[<span style="color:#666">1</span>]
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#080;font-style:italic"># O(n) time || O(n) space</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">is_balanced_dfs</span>(self, root: Optional[TreeNode]) <span style="color:#666">-&gt;</span> <span style="color:#a2f">bool</span>:
</span></span><span style="display:flex;"><span>    stack <span style="color:#666">=</span> [(root, <span style="color:#666">0</span>, <span style="color:#a2f;font-weight:bold">False</span>)]
</span></span><span style="display:flex;"><span>    heights <span style="color:#666">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> stack:
</span></span><span style="display:flex;"><span>        node, height, visited <span style="color:#666">=</span> stack<span style="color:#666">.</span>pop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f;font-weight:bold">not</span> node:
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> visited:
</span></span><span style="display:flex;"><span>            l_height <span style="color:#666">=</span> heights<span style="color:#666">.</span>get(node<span style="color:#666">.</span>left, <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>            r_height <span style="color:#666">=</span> heights<span style="color:#666">.</span>get(node<span style="color:#666">.</span>right, <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f">abs</span>(l_height <span style="color:#666">-</span> r_height) <span style="color:#666">&gt;</span> <span style="color:#666">1</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            heights[node] <span style="color:#666">=</span> <span style="color:#666">1</span> <span style="color:#666">+</span> <span style="color:#a2f">max</span>(l_height, r_height)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>            stack<span style="color:#666">.</span>append((node, height, <span style="color:#a2f;font-weight:bold">True</span>))
</span></span><span style="display:flex;"><span>            stack<span style="color:#666">.</span>append((node<span style="color:#666">.</span>left, height <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#a2f;font-weight:bold">False</span>))
</span></span><span style="display:flex;"><span>            stack<span style="color:#666">.</span>append((node<span style="color:#666">.</span>right, height <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#a2f;font-weight:bold">False</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">True</span>
</span></span></code></pre></div><p>DFS is ideal for this problem because it allows us to compute the height of each subtree while simultaneously checking
if the tree is balanced.</p>
<p>In DFS, we recursively traverse down the tree, visiting a node&rsquo;s children before checking the node itself (hence &quot;
depth-first&quot;). This method is particularly efficient for tree problems like this one, where we need to gather
information from the bottom (leaf nodes) up to the top (root node).</p>
<p>Here&rsquo;s how the DFS works in the context of checking if a tree is height-balanced:</p>
<ol>
<li>
<p>Recursive Traversal: The check function is called recursively on each node&rsquo;s left and right children. This traversal
goes down to the leaf nodes of the tree.</p>
</li>
<li>
<p>Height Calculation: At each node, after the recursive calls return, we calculate the height of the subtree rooted at
that node. The height is determined based on the heights of the left and right subtrees, which are obtained from the
recursive calls.</p>
</li>
<li>
<p>Balance Check: Along with the height calculation, we also check whether the current subtree is balanced. This is done
by checking the height difference between the left and right subtrees. If the difference is more than 1, the subtree
is not balanced.</p>
</li>
<li>
<p>Propagating Information Upward: The function returns two pieces of information for each node: its subtree height and
whether it is balanced. This information is then used by the parent node to perform its own balance check and height
calculation.</p>
</li>
<li>
<p>Final Result: The process continues until the root node, where we get the final decision on whether the whole tree is
balanced.</p>
</li>
</ol>
<p>This approach ensures that each node and its subtrees are only visited once, making it a time-efficient solution. The
DFS strategy is effective here as it allows for the necessary computations and checks to be made at each step in a
single pass through the tree.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/trees">trees</a></li>
					
					<li><a href="/tags/dfs-bfs">dfs-bfs</a></li>
					
					<li><a href="/tags/easy">easy</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/solairerove" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2024  © solairerove |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
