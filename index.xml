<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Headstone lamp - leetcode grind (43)</title>
    <link>https://solairerove.github.io/</link>
    <description>Recent content on Headstone lamp - leetcode grind (43)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Tue, 14 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>100. Same Tree</title>
      <link>https://solairerove.github.io/posts/same_tree/</link>
      <pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/same_tree/</guid>
      <description>To solve this problem, we need to compare two binary trees, p and q, and determine if they are identical. Two binary trees are identical if they have the same structure and their corresponding nodes have the same value.
# O(n) time || O(h) space def is_same_tree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&amp;gt; bool: if not p and not q: return True if not p or not q or p.val != q.</description>
    </item>
    
    <item>
      <title>424. Longest Repeating Character Replacement</title>
      <link>https://solairerove.github.io/posts/longest_repeating_character_replacement/</link>
      <pubDate>Fri, 10 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/longest_repeating_character_replacement/</guid>
      <description># O(n) time | O(1) space def character_replacement(self, s: str, k: int) -&amp;gt; int: freq, max_freq, res = collections.defaultdict(int), 0, 0 low = 0 for high in range(len(s)): freq[s[high]] += 1 max_freq = max(max_freq, freq[s[high]]) if (high - low + 1) - max_freq &amp;gt; k: freq[s[low]] -= 1 low += 1 res = max(res, high - low + 1) return res Detailed Explanation: Initialize Variables: freq: A dictionary to store the frequency of each character in the current window.</description>
    </item>
    
    <item>
      <title>480. Sliding Window Median</title>
      <link>https://solairerove.github.io/posts/sliding_window_median/</link>
      <pubDate>Fri, 10 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/sliding_window_median/</guid>
      <description>class MedianFinder: def __init__(self): self.small, self.large = [], [] self.lazy = collections.defaultdict(int) self.balance = 0 def add(self, num): if not self.small or num &amp;lt;= -self.small[0]: heapq.heappush(self.small, -num) self.balance -= 1 else: heapq.heappush(self.large, num) self.balance += 1 self.rebalance() def remove(self, num): self.lazy[num] += 1 if num &amp;lt;= -self.small[0]: self.balance += 1 else: self.balance -= 1 self.rebalance() self.lazy_remove() def find_median(self): if self.balance == 0: return (-self.small[0] + self.large[0]) / 2 elif self.balance &amp;lt; 0: return -self.</description>
    </item>
    
    <item>
      <title>239. Sliding Window Maximum</title>
      <link>https://solairerove.github.io/posts/sliding_window_maximum/</link>
      <pubDate>Tue, 07 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/sliding_window_maximum/</guid>
      <description># O(n) time | O(k) space def max_sliding_window(self, nums: List[int], k: int) -&amp;gt; List[int]: res = [] dq = collections.deque() for i, n in enumerate(nums): if dq and dq[0] &amp;lt; i - k + 1: dq.popleft() while dq and nums[dq[-1]] &amp;lt;= n: dq.pop() dq.append(i) if i &amp;gt;= k - 1: res.append(nums[dq[0]]) return res This is a classic sliding window problem that can be efficiently solved using a deque (double-ended queue). The idea is to maintain a deque of candidates in decreasing order and to ensure that the candidates are only from the current sliding window.</description>
    </item>
    
    <item>
      <title>295. Find Median from Data Stream</title>
      <link>https://solairerove.github.io/posts/find_median_from_data_stream/</link>
      <pubDate>Tue, 07 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/find_median_from_data_stream/</guid>
      <description>from heapq import heappush, heappop class MedianFinder: # O(1) time || O(n) space def __init__(self): self.small = [] # [0] is highest among small numbers, max heap self.large = [] # [0] is lowest among large numbers, min heap # O(log(n)) time || O(n) space def add_num(self, num: int) -&amp;gt; None: if not self.small or num &amp;lt;= -self.small[0]: heappush(self.small, -num) else: heappush(self.large, num) if len(self.small) &amp;gt; len(self.large) + 1: heappush(self.large, -heappop(self.</description>
    </item>
    
    <item>
      <title>763. Partition Labels</title>
      <link>https://solairerove.github.io/posts/partition_labels/</link>
      <pubDate>Mon, 06 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/partition_labels/</guid>
      <description># O(n) time || O(1) space def partition_labels(self, s: str) -&amp;gt; List[int]: last_occurrence = {c: i for i, c in enumerate(s)} res = [] low = high = 0 for i, c in enumerate(s): high = max(high, last_occurrence[c]) if i == high: res.append(high - low + 1) low = high + 1 return res This problem, often referred to as &amp;ldquo;Partition Labels&amp;rdquo; on LeetCode, requires us to split the string into the maximum number of parts such that no letter appears in more than one part.</description>
    </item>
    
    <item>
      <title>692. Top K Frequent Words</title>
      <link>https://solairerove.github.io/posts/top_k_frequent_words/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/top_k_frequent_words/</guid>
      <description>sorting to obtain the top k frequent words in O(n + m * log(m)) time.
# O(n + m * log(m)) time || O(m) space # n is number of words in list # m is number of unique words # k is number of top freq words def top_k_frequent_sorting(self, words: List[str], k: int) -&amp;gt; List[str]: cnt = collections.Counter(words) return sorted(cnt, key=lambda word: (-cnt[word], word))[:k] heapq library to obtain the top k frequent words in O(n + k * log(m)) time.</description>
    </item>
    
    <item>
      <title>1985. Find the Kth Largest Integer in the Array</title>
      <link>https://solairerove.github.io/posts/find_the_kth_largest_integer_in_the_array/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/find_the_kth_largest_integer_in_the_array/</guid>
      <description>Use Python&amp;rsquo;s heapq library to obtain the kth largest number in O(n * log(k * m)) time.
# O(n * log(k * m)) time || O(k) space # n is len of nums # m is len of each num # k is k def kth_largest_number_heap(self, nums: List[str], k: int) -&amp;gt; str: heap = [] for num in nums: heapq.heappush(heap, int(num)) if len(heap) &amp;gt; k: heapq.heappop(heap) return str(heap[0]) Quickselect with optimisations.</description>
    </item>
    
    <item>
      <title>215. Kth Largest Element in an Array</title>
      <link>https://solairerove.github.io/posts/kth_largest_element_in_an_array/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/kth_largest_element_in_an_array/</guid>
      <description>Use Python&amp;rsquo;s heapq library to obtain the k largest number in O(nlogk) time.
# O(n * log(k)) time || O(k) space def find_kth_largest_heap(self, nums: List[int], k: int) -&amp;gt; int: return heapq.nlargest(k, nums)[-1] Quickselect with optimisations. Works very slow on leetcode cases. Maybe median of medians will help.
# O(max(n, n^2) time || O(1) space def find_kth_largest_quickselect(self, nums: List[int], k: int) -&amp;gt; int: return quickselect(nums, 0, len(nums) - 1, len(nums) - k) # nums[len(nums) - k] def quickselect(arr, low, high, k): if low == high: return arr[low] lt, gt = partition(arr, low, high, random.</description>
    </item>
    
    <item>
      <title>347. Top K Frequent Elements</title>
      <link>https://solairerove.github.io/posts/top_k_frequent_elements/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/top_k_frequent_elements/</guid>
      <description>Quickselect Explained: Quickselect is a cousin of the quicksort algorithm. The idea behind quickselect is to find the k-th smallest (or largest) element without having to sort the entire list.
Steps of Quickselect: Choose a &amp;lsquo;pivot&amp;rsquo; element from the list and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. Reorder the list so that all elements less than the pivot come before (in no particular order) and all elements greater than the pivot come after it (also in no particular order).</description>
    </item>
    
    <item>
      <title>75. Sort Colors</title>
      <link>https://solairerove.github.io/posts/sort_colors/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/sort_colors/</guid>
      <description># O(n) time || O(1) space def sort_colors(self, nums: List[int]) -&amp;gt; None: lt, i, gt = 0, 0, len(nums) - 1 while i &amp;lt;= gt: if nums[i] == 0: nums[i], nums[lt] = nums[lt], nums[i] i, lt = i + 1, lt + 1 elif nums[i] == 2: nums[i], nums[gt] = nums[gt], nums[i] gt -= 1 else: i += 1 This is the famous &amp;ldquo;Dutch National Flag&amp;rdquo; problem. One common way to solve this problem is using a three-pointer approach.</description>
    </item>
    
    <item>
      <title>252. Meeting Rooms</title>
      <link>https://solairerove.github.io/posts/meeting_rooms/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/meeting_rooms/</guid>
      <description># O(n * log(n)) time || O(n) space def can_attend_meetings(self, intervals: List[List[int]]) -&amp;gt; bool: intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): if intervals[i][0] &amp;lt; intervals[i - 1][1]: return False return True # O(n * log(n)) time || O(n) space def can_attend_meetings_shorter(self, intervals: List[List[int]]) -&amp;gt; bool: intervals.sort(key=lambda x: x[0]) return all(intervals[i][0] &amp;gt;= intervals[i - 1][1] for i in range(1, len(intervals))) To determine whether a person can attend all meetings, we need to ensure that no two meetings overlap.</description>
    </item>
    
    <item>
      <title>253. Meeting Rooms II</title>
      <link>https://solairerove.github.io/posts/meeting_rooms_ii/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/meeting_rooms_ii/</guid>
      <description># O(n * log(n)) time || O(n) space def min_meeting_rooms(self, intervals: List[List[int]]) -&amp;gt; int: start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) res = 0 start, end = 0, 0 while start &amp;lt; len(intervals): if start_times[start] &amp;gt;= end_times[end]: res, end = res - 1, end + 1 res, start = res + 1, start + 1 return res To solve this problem, we can think of the start and end times of the intervals as events.</description>
    </item>
    
    <item>
      <title>435. Non-overlapping Intervals</title>
      <link>https://solairerove.github.io/posts/non_overlapping_intervals/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/non_overlapping_intervals/</guid>
      <description># O(n * log(n)) time || O(log(n)) space def erase_overlap_intervals(self, intervals: List[List[int]]) -&amp;gt; int: intervals.sort(key=lambda x: x[1]) res = 0 end = intervals[0][1] for interval in intervals[1:]: if interval[0] &amp;lt; end: res += 1 else: end = interval[1] return res To solve this problem, we can take a greedy approach. The intuition is that if we choose intervals that end early, it gives us more room for subsequent intervals to fit without overlapping.</description>
    </item>
    
    <item>
      <title>5. Longest Palindromic Substring</title>
      <link>https://solairerove.github.io/posts/longest_palindromic_substring/</link>
      <pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/longest_palindromic_substring/</guid>
      <description># O(n^2) time || O(1) space def longest_palindrome(self, s: str) -&amp;gt; str: def expand(i, j): while i &amp;gt;= 0 and j &amp;lt; len(s) and s[i] == s[j]: i, j = i - 1, j + 1 return s[i + 1: j] return max([expand(i, j) for i in range(len(s)) for j in (i, i + 1)], key=len) This problem can be solved using several methods. A common approach is to expand around the center.</description>
    </item>
    
    <item>
      <title>56. Merge Intervals</title>
      <link>https://solairerove.github.io/posts/merge_intervals/</link>
      <pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/merge_intervals/</guid>
      <description># O(n * log(n)) time || O(n) space def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) res = [intervals[0]] for i in range(1, len(intervals)): if intervals[i][0] &amp;gt; res[-1][1]: res.append(intervals[i]) else: res[-1][1] = max(res[-1][1], intervals[i][1]) return res This is a classic interval problem. The idea is to first sort the intervals based on their start times. After sorting, you can then iterate over the sorted intervals and merge those that overlap.</description>
    </item>
    
    <item>
      <title>20. Valid Parentheses</title>
      <link>https://solairerove.github.io/posts/valid_parentheses/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/valid_parentheses/</guid>
      <description># O(n) time || O(n) space def is_valid(self, s: str) -&amp;gt; bool: close_to_open, stack = {&amp;#34;)&amp;#34;: &amp;#34;(&amp;#34;, &amp;#34;]&amp;#34;: &amp;#34;[&amp;#34;, &amp;#34;}&amp;#34;: &amp;#34;{&amp;#34;}, [] for c in s: if c not in close_to_open: stack.append(c) elif stack: if stack.pop() != close_to_open[c]: return False else: return False return not stack Initialize an empty stack. Traverse the string character by character. For each character: If it&amp;rsquo;s an open bracket (&amp;rsquo;(&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, or &amp;lsquo;[&amp;rsquo;), push it onto the stack.</description>
    </item>
    
    <item>
      <title>200. Number of Islands</title>
      <link>https://solairerove.github.io/posts/number_of_islands/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/number_of_islands/</guid>
      <description># O(n * m) time || O(n * m) space def num_islands_dfs(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) def dfs(i, j): if 0 &amp;lt;= i &amp;lt; n and 0 &amp;lt;= j &amp;lt; m and grid[i][j] == &amp;#34;1&amp;#34;: grid[i][j] = &amp;#34;0&amp;#34; dfs(i - 1, j) dfs(i + 1, j) dfs(i, j - 1) dfs(i, j + 1) res = 0 for i in range(n): for j in range(m): if grid[i][j] == &amp;#34;1&amp;#34;: res += 1 dfs(i, j) return res # O(n * m) time || O(n * m) space def num_islands_dfs_shorter(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) def dfs(i, j): if 0 &amp;lt;= i &amp;lt; n and 0 &amp;lt;= j &amp;lt; m and grid[i][j] == &amp;#34;1&amp;#34;: grid[i][j] = &amp;#34;0&amp;#34; list(map(dfs, [i - 1, i + 1, i, i], [j, j, j - 1, j + 1])) res = 0 for i in range(n): for j in range(m): if grid[i][j] == &amp;#34;1&amp;#34;: res += 1 dfs(i, j) return res # O(n * m) time || O(min(n, m)) space def num_islands_bfs(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(i, j): dq = collections.</description>
    </item>
    
    <item>
      <title>301. Remove Invalid Parentheses</title>
      <link>https://solairerove.github.io/posts/remove_invalid_parentheses/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/remove_invalid_parentheses/</guid>
      <description># O(n * 2 ^ n) time || O(2 ^ n) space def remove_invalid_parentheses(self, s: str) -&amp;gt; List[str]: def is_valid(string): cnt = 0 for c in string: if c == &amp;#39;(&amp;#39;: cnt += 1 elif c == &amp;#39;)&amp;#39;: cnt -= 1 if cnt &amp;lt; 0: return False return cnt == 0 res = [] dq, visited, found = collections.deque([s]), {str}, False while dq: curr_str = dq.popleft() if curr_str not in visited: visited.</description>
    </item>
    
    <item>
      <title>977. Squares of a Sorted Array</title>
      <link>https://solairerove.github.io/posts/squares_of_a_sorted_array/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/squares_of_a_sorted_array/</guid>
      <description># O(n) time || O(1) space def sorted_squares(self, nums: List[int]) -&amp;gt; List[int]: res = [0] * len(nums) pos = len(nums) - 1 low, high = 0, len(nums) - 1 while low &amp;lt;= high: if abs(nums[low]) &amp;gt; abs(nums[high]): res[pos] = nums[low] ** 2 low += 1 else: res[pos] = nums[high] ** 2 high -= 1 pos -= 1 return res Given that the array is sorted in non-decreasing order, the negative numbers will be on the left side and the positive numbers on the right.</description>
    </item>
    
    <item>
      <title>15. 3Sum</title>
      <link>https://solairerove.github.io/posts/three_sum/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/three_sum/</guid>
      <description># O(n^2) time || O(1) space def three_sum(self, nums: List[int]) -&amp;gt; List[List[int]]: nums.sort() triplets = [] for i in range(len(nums) - 2): if i &amp;gt; 0 and nums[i] == nums[i - 1]: continue low, high = i + 1, len(nums) - 1 while low &amp;lt; high: sum_ = nums[i] + nums[low] + nums[high] if sum_ == 0: triplets.append([nums[i], nums[low], nums[high]]) low, high = low + 1, high - 1 while low &amp;lt; high and nums[low] == nums[low - 1]: low += 1 while low &amp;lt; high and nums[high] == nums[high + 1]: high -= 1 elif sum_ &amp;lt; 0: low += 1 else: high -= 1 return triplets You can solve this problem using a sorting-based approach combined with the two-pointer technique.</description>
    </item>
    
    <item>
      <title>18. 4Sum</title>
      <link>https://solairerove.github.io/posts/four_sum/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/four_sum/</guid>
      <description># O(n^3) time || O(1) space def four_sum(self, nums: List[int], target: int) -&amp;gt; List[List[int]]: nums.sort() quadruplets = [] for i in range(len(nums) - 3): if i &amp;gt; 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, len(nums) - 2): if j &amp;gt; i + 1 and nums[j] == nums[j - 1]: continue low, high = j + 1, len(nums) - 1 while low &amp;lt; high: sum_ = nums[i] + nums[j] + nums[low] + nums[high] if sum_ == target: quadruplets.</description>
    </item>
    
    <item>
      <title>242. Valid Anagram</title>
      <link>https://solairerove.github.io/posts/valid_anagram/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/valid_anagram/</guid>
      <description># O(n) time || O(1) space def is_anagram(self, s: str, t: str) -&amp;gt; bool: if len(s) != len(t): return False cnt = [0] * 26 for i in range(len(s)): cnt[ord(s[i]) - ord(&amp;#39;a&amp;#39;)] += 1 cnt[ord(t[i]) - ord(&amp;#39;a&amp;#39;)] -= 1 return max(cnt) == 0 # O(n) time || O(n) space def is_anagram_counter(self, s: str, t: str) -&amp;gt; bool: return collections.Counter(s) == collections.Counter(t) Efficient method is to count the occurrences of each character in both strings and then compare the counts.</description>
    </item>
    
    <item>
      <title>409. Longest Palindrome</title>
      <link>https://solairerove.github.io/posts/longest_palindrome/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/longest_palindrome/</guid>
      <description># O(n) time | O(1) space def longest_palindrome(self, s: str) -&amp;gt; int: odds = sum(v % 2 for v in collections.Counter(s).values()) return len(s) - odds + bool(odds) Count Occurrences: Counter(s) provides the counts of each character. Calculate Odds: We determine how many characters have an odd count. Result: The potential length of the palindrome is len(s) - odds, but if there&amp;rsquo;s any character with an odd count (bool(odds) will be True for any positive odd value), we can use one of them as the center of the palindrome.</description>
    </item>
    
    <item>
      <title>438. Find All Anagrams in a String</title>
      <link>https://solairerove.github.io/posts/find_all_anagrams_in_a_string/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/find_all_anagrams_in_a_string/</guid>
      <description># O(n) time | O(1) space def find_anagrams(self, s: str, p: str) -&amp;gt; List[int]: s_cnt, p_cnt = [0] * 26, [0] * 26 for c in s[:len(p)]: s_cnt[ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 for c in p: p_cnt[ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 res = [] if s_cnt == p_cnt: res.append(0) for i in range(len(p), len(s)): s_cnt[ord(s[i]) - ord(&amp;#39;a&amp;#39;)] += 1 s_cnt[ord(s[i - len(p)]) - ord(&amp;#39;a&amp;#39;)] -= 1 if s_cnt == p_cnt: res.</description>
    </item>
    
    <item>
      <title>49. Group Anagrams</title>
      <link>https://solairerove.github.io/posts/group_anagrams/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/group_anagrams/</guid>
      <description># O(w * n * log(n)) time || O(wn) space def group_anagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dic = collections.defaultdict(list) for s in strs: dic[tuple(sorted(s))].append(s) return list(dic.values()) # O(n * m) time || O(n * m) space, # m - number of strings # n - average number of letters def group_anagrams_count_approach(self, strs: List[str]) -&amp;gt; List[List[str]]: def get_key(s): cnt = [0] * 26 for c in s: cnt[ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 return tuple(cnt) dic = collections.</description>
    </item>
    
    <item>
      <title>1. Two Sum</title>
      <link>https://solairerove.github.io/posts/two_sum/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/two_sum/</guid>
      <description># O(n) time || O(n) space def two_sum(self, nums: List[int], target: int) -&amp;gt; List[int]: dic = {} for i, num in enumerate(nums): if target - num in dic: return [dic[target - num], i] dic[num] = i In this solution, we use a dictionary dic to store the numbers encountered so far along with their indices. As we iterate through the array, we check if the complement (target - num) exists in the num_map dictionary.</description>
    </item>
    
    <item>
      <title>1011. Capacity To Ship Packages Within D Days</title>
      <link>https://solairerove.github.io/posts/capacity_to_ship_packages_within_d_days/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/capacity_to_ship_packages_within_d_days/</guid>
      <description># O(n * log(n)) time || O(1) space def ship_within_days(self, weights: List[int], days: int) -&amp;gt; int: low, high = max(weights), sum(weights) while low &amp;lt;= high: mid = low + (high - low) // 2 days_required, curr_weight = 1, 0 for weight in weights: if curr_weight + weight &amp;lt;= mid: curr_weight += weight else: days_required, curr_weight = days_required + 1, weight if days_required &amp;lt;= days: high = mid - 1 else: low = mid + 1 return low Determine the search space: The minimum possible weight capacity of the ship would be the maximum weight among all the packages, and the maximum possible weight capacity of the ship would be the sum of all the package weights.</description>
    </item>
    
    <item>
      <title>136. Single Number</title>
      <link>https://solairerove.github.io/posts/single_number/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/single_number/</guid>
      <description># O(n) time || O(1) space def single_number(self, nums: List[int]) -&amp;gt; int: res = 0 for n in nums: res ^= n return res # O(n) time || O(1) space def single_number_reduce(self, nums: List[int]) -&amp;gt; int: return functools.reduce(lambda x, y: x ^ y, nums) To find the element that appears only once in the array with a linear runtime complexity and constant extra space, you can utilize the XOR operator.</description>
    </item>
    
    <item>
      <title>875. Koko Eating Bananas</title>
      <link>https://solairerove.github.io/posts/koko_eating_bananas/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/koko_eating_bananas/</guid>
      <description># O(n * log(max(p)) time || O(1) space def min_eating_speed(self, piles: List[int], h: int) -&amp;gt; int: low, high = 1, max(piles) while low &amp;lt; high: mid = low + (high - low) // 2 if sum(math.ceil(pile / mid) for pile in piles) &amp;lt;= h: high = mid else: low = mid + 1 return high if the current speed is workable, the minimum workable speed should be on its left inclusively.</description>
    </item>
    
    <item>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link>https://solairerove.github.io/posts/find_minimum_in_rotated_sorted_array/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/find_minimum_in_rotated_sorted_array/</guid>
      <description># O(log(n)) time || O(1) space def find_min(self, nums: List[int]) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt; high: mid = low + (high - low) // 2 if nums[mid] &amp;gt; nums[high]: low = mid + 1 else: high = mid return nums[high] array might be offset but still is sorted. use binary search, take in consider in which part to have a search. if mid element bigger than last one, low border is mid + 1</description>
    </item>
    
    <item>
      <title>33. Search in Rotated Sorted Array</title>
      <link>https://solairerove.github.io/posts/search_in_rotated_sorted_array/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_in_rotated_sorted_array/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid if nums[low] &amp;lt;= nums[mid]: if nums[low] &amp;lt;= target &amp;lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &amp;lt;= target &amp;lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 array might be offset but still is sorted.</description>
    </item>
    
    <item>
      <title>81. Search in Rotated Sorted Array II</title>
      <link>https://solairerove.github.io/posts/search_in_rotated_sorted_array_ii/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_in_rotated_sorted_array_ii/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; bool: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return True while low &amp;lt; mid and nums[low] == nums[mid]: low += 1 if nums[low] &amp;lt;= nums[mid]: if nums[low] &amp;lt;= target &amp;lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &amp;lt;= target &amp;lt;= nums[high]: low = mid + 1 else: high = mid - 1 return False array might be offset but still is sorted.</description>
    </item>
    
    <item>
      <title>278. First Bad Version</title>
      <link>https://solairerove.github.io/posts/first_bad_version/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/first_bad_version/</guid>
      <description># The isBadVersion API is already defined for you. # def isBadVersion(version: int) -&amp;gt; bool: # O(log(n)) time || O(1) space def first_bad_version(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 if isBadVersion(mid): high = mid - 1 else: low = mid + 1 return low you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>374. Guess Number Higher or Lower</title>
      <link>https://solairerove.github.io/posts/guess_number_higher_or_lower/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/guess_number_higher_or_lower/</guid>
      <description># @param num, your guess # @return -1 if num is higher than the picked number # 1 if num is lower than the picked number # otherwise return 0 # def guess(num: int) -&amp;gt; int: # O(log(n)) time || O(1) space def guess_number(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 cmp = guess(mid) if cmp == 0: return mid elif cmp == -1: high = mid - 1 else: low = mid + 1 you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>704. Binary Search</title>
      <link>https://solairerove.github.io/posts/binary_search/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/binary_search/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid elif target &amp;lt; nums[mid]: high = mid - 1 else: low = mid + 1 return -1 classic default binary search. have two pointers as search border. decrease search borders two times on each iteration like you&amp;rsquo;re trying to find word in dictionary book.</description>
    </item>
    
    <item>
      <title>74. Search a 2D Matrix</title>
      <link>https://solairerove.github.io/posts/search_a_2d_matrix/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_a_2d_matrix/</guid>
      <description># O(log(m * n)) time || O(1) space def search_matrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 mid_row, mid_col = divmod(mid, cols) if target == matrix[mid_row][mid_col]: return True elif target &amp;lt; matrix[mid_row][mid_col]: high = mid - 1 else: low = mid + 1 return False to get midpoint in the matrix, we use the divmod function with mid and cols</description>
    </item>
    
    <item>
      <title>844. Backspace String Compare</title>
      <link>https://solairerove.github.io/posts/backspace_string_compare/</link>
      <pubDate>Thu, 19 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/backspace_string_compare/</guid>
      <description># O(n + m) time || O(1) space def backspace_compare_two_pointers(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): skip = 0 for c in reversed(to_trim): if c == &amp;#39;#&amp;#39;: skip += 1 elif skip: skip -= 1 else: yield c return all(a == b for a, b in itertools.zip_longest(trim(s), trim(t))) # O(n + m) time || O(n + m) space def backspace_compare_stack(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): stack = [] for c in to_trim: if c !</description>
    </item>
    
    <item>
      <title>141. Linked List Cycle</title>
      <link>https://solairerove.github.io/posts/linked_list_cycle/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/linked_list_cycle/</guid>
      <description># O(n) time || O(1) space def has_cycle(self, head: Optional[ListNode]) -&amp;gt; bool: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: return True return False Floyd&#39;s Cycle Finding Algorithm by considering two pointers at different speed. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</description>
    </item>
    
    <item>
      <title>2. Add Two Numbers</title>
      <link>https://solairerove.github.io/posts/add_two_numbers/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/add_two_numbers/</guid>
      <description># O(max(n, m)) time || O(1) space def add_two_numbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: sentinel = ListNode() prev = sentinel hold = 0 while l1 or l2: curr_sum = 0 if l1: curr_sum, l1 = curr_sum + l1.val, l1.next if l2: curr_sum, l2 = curr_sum + l2.val, l2.next curr_sum += hold prev.next, hold = ListNode(curr_sum % 10), curr_sum // 10 prev = prev.next if hold: prev.next = ListNode(hold) return sentinel.</description>
    </item>
    
    <item>
      <title>206. Reverse Linked List</title>
      <link>https://solairerove.github.io/posts/reverse_linked_list/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/reverse_linked_list/</guid>
      <description># O(n) time || O(1) space def reverse_list(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: prev, curr = None, head while curr: curr.next, prev, curr = prev, curr, curr.next return prev traverse linked list using curr pointer. relink curr.next to prev each step on iteration. return the prev as head of reversed list</description>
    </item>
    
    <item>
      <title>23. Merge k Sorted Lists</title>
      <link>https://solairerove.github.io/posts/merge_k_sorted_lists/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/merge_k_sorted_lists/</guid>
      <description># O(n * log(k)) time | O(1) space # n - is total number of nodes # k - is number of linked lists def merge_k_lists(self, lists: List[Optional[ListNode]]) -&amp;gt; Optional[ListNode]: if not lists: return None if len(lists) == 1: return lists[0] interval = 1 while interval &amp;lt; len(lists): for i in range(0, len(lists) - interval, interval * 2): lists[i] = self.merge(lists[i], lists[i + interval]) interval *= 2 return lists[0] # 21.</description>
    </item>
    
    <item>
      <title>876. Middle of the Linked List</title>
      <link>https://solairerove.github.io/posts/middle_of_the_linked_list/</link>
      <pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/middle_of_the_linked_list/</guid>
      <description># O(n) time || O(1) space def middle_node(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: if not head.next: return head slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow fast pointer traverse two times faster than slow, so when fast is done, slow is in middle of lined list</description>
    </item>
    
    <item>
      <title>11. Container With Most Water</title>
      <link>https://solairerove.github.io/posts/container_with_most_water/</link>
      <pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/container_with_most_water/</guid>
      <description># O(n) time || O(1) space def max_area(self, height: List[int]) -&amp;gt; int: res, low, high = 0, 0, len(height) - 1 while low &amp;lt; high: res = max(res, (high - low) * (min(height[low], height[high]))) if height[low] &amp;lt;= height[high]: low += 1 else: high -= 1 return res This problem is known as the &amp;ldquo;Container With Most Water&amp;rdquo; and is a well-known example of a two-pointer technique.
Here&amp;rsquo;s the strategy to solve it:</description>
    </item>
    
  </channel>
</rss>
