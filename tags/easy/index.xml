<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>easy on Headstone lamp - leetcode grind</title>
    <link>https://solairerove.github.io/tags/easy/</link>
    <description>Recent content in easy on Headstone lamp - leetcode grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Mon, 23 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/tags/easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. Two Sum</title>
      <link>https://solairerove.github.io/posts/two_sum/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/two_sum/</guid>
      <description># O(n) time || O(n) space def two_sum(self, nums: List[int], target: int) -&amp;gt; List[int]: dic = {} for i, num in enumerate(nums): if target - num in dic: return [dic[target - num], i] dic[num] = i In this solution, we use a dictionary dic to store the numbers encountered so far along with their indices. As we iterate through the array, we check if the complement (target - num) exists in the num_map dictionary.</description>
    </item>
    
    <item>
      <title>136. Single Number</title>
      <link>https://solairerove.github.io/posts/single_number/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/single_number/</guid>
      <description># O(n) time || O(1) space def single_number(self, nums: List[int]) -&amp;gt; int: res = 0 for n in nums: res ^= n return res # O(n) time || O(1) space def single_number_reduce(self, nums: List[int]) -&amp;gt; int: return functools.reduce(lambda x, y: x ^ y, nums) To find the element that appears only once in the array with a linear runtime complexity and constant extra space, you can utilize the XOR operator.</description>
    </item>
    
    <item>
      <title>278. First Bad Version</title>
      <link>https://solairerove.github.io/posts/first_bad_version/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/first_bad_version/</guid>
      <description># The isBadVersion API is already defined for you. # def isBadVersion(version: int) -&amp;gt; bool: # O(log(n)) time || O(1) space def first_bad_version(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 if isBadVersion(mid): high = mid - 1 else: low = mid + 1 return low you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>374. Guess Number Higher or Lower</title>
      <link>https://solairerove.github.io/posts/guess_number_higher_or_lower/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/guess_number_higher_or_lower/</guid>
      <description># @param num, your guess # @return -1 if num is higher than the picked number # 1 if num is lower than the picked number # otherwise return 0 # def guess(num: int) -&amp;gt; int: # O(log(n)) time || O(1) space def guess_number(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 cmp = guess(mid) if cmp == 0: return mid elif cmp == -1: high = mid - 1 else: low = mid + 1 you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>704. Binary Search</title>
      <link>https://solairerove.github.io/posts/binary_search/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/binary_search/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid elif target &amp;lt; nums[mid]: high = mid - 1 else: low = mid + 1 return -1 classic default binary search. have two pointers as search border. decrease search borders two times on each iteration like you&amp;rsquo;re trying to find word in dictionary book.</description>
    </item>
    
    <item>
      <title>844. Backspace String Compare</title>
      <link>https://solairerove.github.io/posts/backspace_string_compare/</link>
      <pubDate>Thu, 19 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/backspace_string_compare/</guid>
      <description># O(n + m) time || O(1) space def backspace_compare_two_pointers(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): skip = 0 for c in reversed(to_trim): if c == &amp;#39;#&amp;#39;: skip += 1 elif skip: skip -= 1 else: yield c return all(a == b for a, b in itertools.zip_longest(trim(s), trim(t))) # O(n + m) time || O(n + m) space def backspace_compare_stack(self, s: str, t: str) -&amp;gt; bool: def trim(line): stack = [] for c in line: if c !</description>
    </item>
    
    <item>
      <title>141. Linked List Cycle</title>
      <link>https://solairerove.github.io/posts/linked_list_cycle/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/linked_list_cycle/</guid>
      <description># O(n) time || O(1) space def has_cycle(self, head: Optional[ListNode]) -&amp;gt; bool: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: return True return False Floyd&#39;s Cycle Finding Algorithm by considering two pointers at different speed. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</description>
    </item>
    
    <item>
      <title>206. Reverse Linked List</title>
      <link>https://solairerove.github.io/posts/reverse_linked_list/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/reverse_linked_list/</guid>
      <description># O(n) time || O(1) space def reverse_list(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: prev, curr = None, head while curr: curr.next, prev, curr = prev, curr, curr.next return prev traverse linked list using curr pointer. relink curr.next to prev each step on iteration. return the prev as head of reversed list</description>
    </item>
    
    <item>
      <title>876. Middle of the Linked List</title>
      <link>https://solairerove.github.io/posts/middle_of_the_linked_list/</link>
      <pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/middle_of_the_linked_list/</guid>
      <description># O(n) time || O(1) space def middle_node(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: if not head.next: return head slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow fast pointer traverse two times faster than slow, so when fast is done, slow is in middle of lined list</description>
    </item>
    
  </channel>
</rss>
