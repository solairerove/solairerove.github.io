<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>heap on Headstone lamp - leetcode grind</title>
    <link>https://solairerove.github.io/tags/heap/</link>
    <description>Recent content in heap on Headstone lamp - leetcode grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Wed, 01 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/tags/heap/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>347. Top K Frequent Elements</title>
      <link>https://solairerove.github.io/posts/top_k_frequent_elements/</link>
      <pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/top_k_frequent_elements/</guid>
      <description>use Python&amp;rsquo;s heapq library to obtain the top k frequent numbers in O(nlogk) time. # O(n * log(k)) time || O(n + k) space def top_k_frequent_heap(self, nums: List[int], k: int) -&amp;gt; List[int]: if len(nums) == k: return nums cnt = collections.Counter(nums) return heapq.nlargest(k, cnt.keys(), key=cnt.get) calculate how frequent you can see num in arr create frequency array where index is frequency and value is arr of keys traverse from end to start and append to res don&amp;rsquo;t use this solution during interview # O(n) time || O(n) space def top_k_frequent_linear(self, nums: List[int], k: int) -&amp;gt; List[int]: if k == len(nums): return nums cnt = collections.</description>
    </item>
    
  </channel>
</rss>
