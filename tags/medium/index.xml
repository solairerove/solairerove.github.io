<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>medium on Headstone lamp - leetcode grind</title>
    <link>https://solairerove.github.io/tags/medium/</link>
    <description>Recent content in medium on Headstone lamp - leetcode grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Sun, 22 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/tags/medium/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link>https://solairerove.github.io/posts/find_minimum_in_rotated_sorted_array/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/find_minimum_in_rotated_sorted_array/</guid>
      <description># O(log(n)) time || O(1) space def find_min(self, nums: List[int]) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt; high: mid = low + (high - low) // 2 if nums[mid] &amp;gt; nums[high]: low = mid + 1 else: high = mid return nums[high] array might be offset but still is sorted. use binary search, take in consider in which part to have a search. if mid element bigger than last one, low border is mid + 1</description>
    </item>
    
    <item>
      <title>33. Search in Rotated Sorted Array</title>
      <link>https://solairerove.github.io/posts/search_in_rotated_sorted_array/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_in_rotated_sorted_array/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid if nums[low] &amp;lt;= nums[mid]: if nums[low] &amp;lt;= target &amp;lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &amp;lt;= target &amp;lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 array might be offset but still is sorted.</description>
    </item>
    
    <item>
      <title>81. Search in Rotated Sorted Array II</title>
      <link>https://solairerove.github.io/posts/search_in_rotated_sorted_array_ii/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_in_rotated_sorted_array_ii/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; bool: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return True while low &amp;lt; mid and nums[low] == nums[mid]: low += 1 if nums[low] &amp;lt;= nums[mid]: if nums[low] &amp;lt;= target &amp;lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &amp;lt;= target &amp;lt;= nums[high]: low = mid + 1 else: high = mid - 1 return False array might be offset but still is sorted.</description>
    </item>
    
    <item>
      <title>74. Search a 2D Matrix</title>
      <link>https://solairerove.github.io/posts/search_a_2d_matrix/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_a_2d_matrix/</guid>
      <description># O(log(m * n)) time || O(1) space def search_matrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 mid_row, mid_col = divmod(mid, cols) if target == matrix[mid_row][mid_col]: return True elif target &amp;lt; matrix[mid_row][mid_col]: high = mid - 1 else: low = mid + 1 return False to get midpoint in the matrix, we use the divmod function with mid and cols</description>
    </item>
    
    <item>
      <title>2. Add Two Numbers</title>
      <link>https://solairerove.github.io/posts/add_two_numbers/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/add_two_numbers/</guid>
      <description># O(max(n, m)) time || O(1) space def add_two_numbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: sentinel = ListNode() prev = sentinel hold = 0 while l1 or l2: curr_sum = 0 if l1: curr_sum, l1 = curr_sum + l1.val, l1.next if l2: curr_sum, l2 = curr_sum + l2.val, l2.next curr_sum += hold prev.next, hold = ListNode(curr_sum % 10), curr_sum // 10 prev = prev.next if hold: prev.next = ListNode(hold) return sentinel.</description>
    </item>
    
    <item>
      <title>11. Container With Most Water</title>
      <link>https://solairerove.github.io/posts/container_with_most_water/</link>
      <pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/container_with_most_water/</guid>
      <description># O(n) time || O(1) space def max_area(self, height: List[int]) -&amp;gt; int: area, low, high = 0, 0, len(height) - 1 while low &amp;lt; high: area = max(area, min(height[low], height[high]) * (high - low)) if height[low] &amp;lt;= height[high]: low += 1 else: high -= 1 return area </description>
    </item>
    
  </channel>
</rss>
