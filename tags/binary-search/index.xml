<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>binary-search on Headstone lamp - leetcode grind</title>
    <link>https://solairerove.github.io/tags/binary-search/</link>
    <description>Recent content in binary-search on Headstone lamp - leetcode grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Sun, 22 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/tags/binary-search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link>https://solairerove.github.io/posts/find_minimum_in_rotated_sorted_array/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/find_minimum_in_rotated_sorted_array/</guid>
      <description># O(log(n)) time || O(1) space def find_min(self, nums: List[int]) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt; high: mid = low + (high - low) // 2 if nums[mid] &amp;gt; nums[high]: low = mid + 1 else: high = mid return nums[high] array might be offset but still is sorted. use binary search, take in consider in which part to have a search. if mid element bigger than last one, low border is mid + 1</description>
    </item>
    
    <item>
      <title>33. Search in Rotated Sorted Array</title>
      <link>https://solairerove.github.io/posts/search_in_rotated_sorted_array/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_in_rotated_sorted_array/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid if nums[low] &amp;lt;= nums[mid]: if nums[low] &amp;lt;= target &amp;lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &amp;lt;= target &amp;lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 array might be offset but still is sorted.</description>
    </item>
    
    <item>
      <title>81. Search in Rotated Sorted Array II</title>
      <link>https://solairerove.github.io/posts/search_in_rotated_sorted_array_ii/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_in_rotated_sorted_array_ii/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; bool: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return True while low &amp;lt; mid and nums[low] == nums[mid]: low += 1 if nums[low] &amp;lt;= nums[mid]: if nums[low] &amp;lt;= target &amp;lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &amp;lt;= target &amp;lt;= nums[high]: low = mid + 1 else: high = mid - 1 return False array might be offset but still is sorted.</description>
    </item>
    
    <item>
      <title>278. First Bad Version</title>
      <link>https://solairerove.github.io/posts/first_bad_version/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/first_bad_version/</guid>
      <description># The isBadVersion API is already defined for you. # def isBadVersion(version: int) -&amp;gt; bool: # O(log(n)) time || O(1) space def first_bad_version(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 if isBadVersion(mid): high = mid - 1 else: low = mid + 1 return low you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>374. Guess Number Higher or Lower</title>
      <link>https://solairerove.github.io/posts/guess_number_higher_or_lower/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/guess_number_higher_or_lower/</guid>
      <description># @param num, your guess # @return -1 if num is higher than the picked number # 1 if num is lower than the picked number # otherwise return 0 # def guess(num: int) -&amp;gt; int: # O(log(n)) time || O(1) space def guess_number(self, n: int) -&amp;gt; int: low, high = 1, n while low &amp;lt;= high: mid = low + (high - low) // 2 cmp = guess(mid) if cmp == 0: return mid elif cmp == -1: high = mid - 1 else: low = mid + 1 you can use binary search to decrease count of api calls.</description>
    </item>
    
    <item>
      <title>704. Binary Search</title>
      <link>https://solairerove.github.io/posts/binary_search/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/binary_search/</guid>
      <description># O(log(n)) time || O(1) space def search(self, nums: List[int], target: int) -&amp;gt; int: low, high = 0, len(nums) - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 if target == nums[mid]: return mid elif target &amp;lt; nums[mid]: high = mid - 1 else: low = mid + 1 return -1 classic default binary search. have two pointers as search border. decrease search borders two times on each iteration like you&amp;rsquo;re trying to find word in dictionary book.</description>
    </item>
    
    <item>
      <title>74. Search a 2D Matrix</title>
      <link>https://solairerove.github.io/posts/search_a_2d_matrix/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/search_a_2d_matrix/</guid>
      <description># O(log(m * n)) time || O(1) space def search_matrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &amp;lt;= high: mid = low + (high - low) // 2 mid_row, mid_col = divmod(mid, cols) if target == matrix[mid_row][mid_col]: return True elif target &amp;lt; matrix[mid_row][mid_col]: high = mid - 1 else: low = mid + 1 return False to get midpoint in the matrix, we use the divmod function with mid and cols</description>
    </item>
    
  </channel>
</rss>
