<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>arrays on Headstone lamp - leetcode grind</title>
    <link>https://solairerove.github.io/tags/arrays/</link>
    <description>Recent content in arrays on Headstone lamp - leetcode grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Fri, 27 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/tags/arrays/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>5. Longest Palindromic Substring</title>
      <link>https://solairerove.github.io/posts/longest_palindromic_substring/</link>
      <pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/longest_palindromic_substring/</guid>
      <description># O(n^2) time || O(1) space def longest_palindrome(self, s: str) -&amp;gt; str: def expand(i, j): while i &amp;gt;= 0 and j &amp;lt; len(s) and s[i] == s[j]: i, j = i - 1, j + 1 return s[i + 1: j] return max([expand(i, j) for i in range(len(s)) for j in (i, i + 1)], key=len) This problem can be solved using several methods. A common approach is to expand around the center.</description>
    </item>
    
    <item>
      <title>56. Merge Intervals</title>
      <link>https://solairerove.github.io/posts/merge_intervals/</link>
      <pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/merge_intervals/</guid>
      <description># O(n * log(n)) time || O(n) space def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) res = [intervals[0]] for i in range(1, len(intervals)): if intervals[i][0] &amp;gt; res[-1][1]: res.append(intervals[i]) else: res[-1][1] = max(res[-1][1], intervals[i][1]) return res This is a classic interval problem. The idea is to first sort the intervals based on their start times. After sorting, you can then iterate over the sorted intervals and merge those that overlap.</description>
    </item>
    
    <item>
      <title>20. Valid Parentheses</title>
      <link>https://solairerove.github.io/posts/valid_parentheses/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/valid_parentheses/</guid>
      <description># O(n) time || O(n) space def is_valid(self, s: str) -&amp;gt; bool: close_to_open, stack = {&amp;#34;)&amp;#34;: &amp;#34;(&amp;#34;, &amp;#34;]&amp;#34;: &amp;#34;[&amp;#34;, &amp;#34;}&amp;#34;: &amp;#34;{&amp;#34;}, [] for c in s: if c not in close_to_open: stack.append(c) elif stack: if stack.pop() != close_to_open[c]: return False else: return False return not stack Initialize an empty stack. Traverse the string character by character. For each character: If it&amp;rsquo;s an open bracket (&amp;rsquo;(&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, or &amp;lsquo;[&amp;rsquo;), push it onto the stack.</description>
    </item>
    
    <item>
      <title>200. Number of Islands</title>
      <link>https://solairerove.github.io/posts/number_of_islands/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/number_of_islands/</guid>
      <description># O(n * m) time || O(n * m) space def num_islands_dfs(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) def dfs(i, j): if 0 &amp;lt;= i &amp;lt; n and 0 &amp;lt;= j &amp;lt; m and grid[i][j] == &amp;#34;1&amp;#34;: grid[i][j] = &amp;#34;0&amp;#34; dfs(i - 1, j) dfs(i + 1, j) dfs(i, j - 1) dfs(i, j + 1) res = 0 for i in range(n): for j in range(m): if grid[i][j] == &amp;#34;1&amp;#34;: res += 1 dfs(i, j) return res # O(n * m) time || O(n * m) space def num_islands_dfs_shorter(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) def dfs(i, j): if 0 &amp;lt;= i &amp;lt; n and 0 &amp;lt;= j &amp;lt; m and grid[i][j] == &amp;#34;1&amp;#34;: grid[i][j] = &amp;#34;0&amp;#34; list(map(dfs, [i - 1, i + 1, i, i], [j, j, j - 1, j + 1])) res = 0 for i in range(n): for j in range(m): if grid[i][j] == &amp;#34;1&amp;#34;: res += 1 dfs(i, j) return res # O(n * m) time || O(min(n, m)) space def num_islands_bfs(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(i, j): dq = collections.</description>
    </item>
    
    <item>
      <title>301. Remove Invalid Parentheses</title>
      <link>https://solairerove.github.io/posts/remove_invalid_parentheses/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/remove_invalid_parentheses/</guid>
      <description># O(n * 2 ^ n) time || O(2 ^ n) space def remove_invalid_parentheses(self, s: str) -&amp;gt; List[str]: def is_valid(string): cnt = 0 for c in string: if c == &amp;#39;(&amp;#39;: cnt += 1 elif c == &amp;#39;)&amp;#39;: cnt -= 1 if cnt &amp;lt; 0: return False return cnt == 0 res = [] dq, visited, found = collections.deque([s]), {str}, False while dq: curr_str = dq.popleft() if curr_str not in visited: visited.</description>
    </item>
    
    <item>
      <title>977. Squares of a Sorted Array</title>
      <link>https://solairerove.github.io/posts/squares_of_a_sorted_array/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/squares_of_a_sorted_array/</guid>
      <description># O(n) time || O(1) space def sorted_squares(self, nums: List[int]) -&amp;gt; List[int]: res = [0] * len(nums) pos = len(nums) - 1 low, high = 0, len(nums) - 1 while low &amp;lt;= high: if abs(nums[low]) &amp;gt; abs(nums[high]): res[pos] = nums[low] ** 2 low += 1 else: res[pos] = nums[high] ** 2 high -= 1 pos -= 1 return res Given that the array is sorted in non-decreasing order, the negative numbers will be on the left side and the positive numbers on the right.</description>
    </item>
    
    <item>
      <title>844. Backspace String Compare</title>
      <link>https://solairerove.github.io/posts/backspace_string_compare/</link>
      <pubDate>Thu, 19 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/backspace_string_compare/</guid>
      <description># O(n + m) time || O(1) space def backspace_compare_two_pointers(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): skip = 0 for c in reversed(to_trim): if c == &amp;#39;#&amp;#39;: skip += 1 elif skip: skip -= 1 else: yield c return all(a == b for a, b in itertools.zip_longest(trim(s), trim(t))) # O(n + m) time || O(n + m) space def backspace_compare_stack(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): stack = [] for c in to_trim: if c !</description>
    </item>
    
    <item>
      <title>11. Container With Most Water</title>
      <link>https://solairerove.github.io/posts/container_with_most_water/</link>
      <pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/container_with_most_water/</guid>
      <description># O(n) time || O(1) space def max_area(self, height: List[int]) -&amp;gt; int: area, low, high = 0, 0, len(height) - 1 while low &amp;lt; high: area = max(area, min(height[low], height[high]) * (high - low)) if height[low] &amp;lt;= height[high]: low += 1 else: high -= 1 return area </description>
    </item>
    
  </channel>
</rss>
