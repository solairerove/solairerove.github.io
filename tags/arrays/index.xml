<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>arrays on Headstone lamp - leetcode grind</title>
    <link>https://solairerove.github.io/tags/arrays/</link>
    <description>Recent content in arrays on Headstone lamp - leetcode grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Thu, 26 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/tags/arrays/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>20. Valid Parentheses</title>
      <link>https://solairerove.github.io/posts/valid_parentheses/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/valid_parentheses/</guid>
      <description># O(n) time || O(n) space def is_valid(self, s: str) -&amp;gt; bool: close_to_open, stack = {&amp;#34;)&amp;#34;: &amp;#34;(&amp;#34;, &amp;#34;]&amp;#34;: &amp;#34;[&amp;#34;, &amp;#34;}&amp;#34;: &amp;#34;{&amp;#34;}, [] for c in s: if c not in close_to_open: stack.append(c) elif stack: if stack.pop() != close_to_open[c]: return False else: return False return not stack Initialize an empty stack. Traverse the string character by character. For each character: If it&amp;rsquo;s an open bracket (&amp;rsquo;(&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, or &amp;lsquo;[&amp;rsquo;), push it onto the stack.</description>
    </item>
    
    <item>
      <title>200. Number of Islands</title>
      <link>https://solairerove.github.io/posts/number_of_islands/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/number_of_islands/</guid>
      <description># O(n * m) time || O(n * m) space def num_islands_dfs(self, grid: List[List[str]]) -&amp;gt; int: if not grid: return 0 n, m = len(grid), len(grid[0]) def dfs(i, j): if 0 &amp;lt;= i &amp;lt; n and 0 &amp;lt;= j &amp;lt; m and grid[i][j] == &amp;#34;1&amp;#34;: grid[i][j] = &amp;#34;0&amp;#34; dfs(i - 1, j) dfs(i + 1, j) dfs(i, j - 1) dfs(i, j + 1) res = 0 for i in range(n): for j in range(m): if grid[i][j] == &amp;#34;1&amp;#34;: res += 1 dfs(i, j) return res # O(n * m) time || O(n * m) space def num_islands_dfs_shorter(self, grid: List[List[str]]) -&amp;gt; int: if not grid: return 0 n, m = len(grid), len(grid[0]) def dfs(i, j): if 0 &amp;lt;= i &amp;lt; n and 0 &amp;lt;= j &amp;lt; m and grid[i][j] == &amp;#34;1&amp;#34;: grid[i][j] = &amp;#34;0&amp;#34; list(map(dfs, [i - 1, i + 1, i, i], [j, j, j - 1, j + 1])) res = 0 for i in range(n): for j in range(m): if grid[i][j] == &amp;#34;1&amp;#34;: res += 1 dfs(i, j) return res # O(n * m) time || O(min(n, m)) space def num_islands_bfs(self, grid: List[List[str]]) -&amp;gt; int: if not grid: return 0 n, m = len(grid), len(grid[0]) res = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(i, j): dq = collections.</description>
    </item>
    
    <item>
      <title>301. Remove Invalid Parentheses</title>
      <link>https://solairerove.github.io/posts/remove_invalid_parentheses/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/remove_invalid_parentheses/</guid>
      <description># O(n) time || O(n) space def remove_invalid_parentheses(self, s: str) -&amp;gt; List[str]: def is_valid(string): cnt = 0 for c in string: if c == &amp;#39;(&amp;#39;: cnt += 1 elif c == &amp;#39;)&amp;#39;: cnt -= 1 if cnt &amp;lt; 0: return False return cnt == 0 res, stack, visited, found = [], [s], {s}, False while stack and not found: for curr_str in stack: if is_valid(curr_str): found = True res.append(curr_str) elif not found: for j in range(len(curr_str)): if curr_str[j] not in [&amp;#39;(&amp;#39;, &amp;#39;)&amp;#39;]: continue new_str = curr_str[:j] + curr_str[j + 1:] if new_str not in visited: visited.</description>
    </item>
    
    <item>
      <title>977. Squares of a Sorted Array</title>
      <link>https://solairerove.github.io/posts/squares_of_a_sorted_array/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/squares_of_a_sorted_array/</guid>
      <description># O(n) time || O(1) space def sorted_squares(self, nums: List[int]) -&amp;gt; List[int]: res = [0] * len(nums) pos = len(nums) - 1 low, high = 0, len(nums) - 1 while low &amp;lt;= high: if abs(nums[low]) &amp;gt; abs(nums[high]): res[pos] = nums[low] ** 2 low += 1 else: res[pos] = nums[high] ** 2 high -= 1 pos -= 1 return res Given that the array is sorted in non-decreasing order, the negative numbers will be on the left side and the positive numbers on the right.</description>
    </item>
    
    <item>
      <title>844. Backspace String Compare</title>
      <link>https://solairerove.github.io/posts/backspace_string_compare/</link>
      <pubDate>Thu, 19 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/backspace_string_compare/</guid>
      <description># O(n + m) time || O(1) space def backspace_compare_two_pointers(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): skip = 0 for c in reversed(to_trim): if c == &amp;#39;#&amp;#39;: skip += 1 elif skip: skip -= 1 else: yield c return all(a == b for a, b in itertools.zip_longest(trim(s), trim(t))) # O(n + m) time || O(n + m) space def backspace_compare_stack(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): stack = [] for c in to_trim: if c !</description>
    </item>
    
    <item>
      <title>11. Container With Most Water</title>
      <link>https://solairerove.github.io/posts/container_with_most_water/</link>
      <pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/container_with_most_water/</guid>
      <description># O(n) time || O(1) space def max_area(self, height: List[int]) -&amp;gt; int: area, low, high = 0, 0, len(height) - 1 while low &amp;lt; high: area = max(area, min(height[low], height[high]) * (high - low)) if height[low] &amp;lt;= height[high]: low += 1 else: high -= 1 return area </description>
    </item>
    
  </channel>
</rss>
