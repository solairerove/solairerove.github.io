<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>arrays on Headstone lamp - leetcode grind (48)</title>
    <link>https://solairerove.github.io/tags/arrays/</link>
    <description>Recent content in arrays on Headstone lamp - leetcode grind (48)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© solairerove</copyright>
    <lastBuildDate>Mon, 06 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://solairerove.github.io/tags/arrays/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>763. Partition Labels</title>
      <link>https://solairerove.github.io/posts/partition_labels/</link>
      <pubDate>Mon, 06 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/partition_labels/</guid>
      <description># O(n) time || O(1) space def partition_labels(self, s: str) -&amp;gt; List[int]: last_occurrence = {c: i for i, c in enumerate(s)} res = [] low = high = 0 for i, c in enumerate(s): high = max(high, last_occurrence[c]) if i == high: res.append(high - low + 1) low = high + 1 return res This problem, often referred to as &amp;ldquo;Partition Labels&amp;rdquo; on LeetCode, requires us to split the string into the maximum number of parts such that no letter appears in more than one part.</description>
    </item>
    
    <item>
      <title>692. Top K Frequent Words</title>
      <link>https://solairerove.github.io/posts/top_k_frequent_words/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/top_k_frequent_words/</guid>
      <description>sorting to obtain the top k frequent words in O(n + m * log(m)) time.
# O(n + m * log(m)) time || O(m) space # n is number of words in list # m is number of unique words # k is number of top freq words def top_k_frequent_sorting(self, words: List[str], k: int) -&amp;gt; List[str]: cnt = collections.Counter(words) return sorted(cnt, key=lambda word: (-cnt[word], word))[:k] heapq library to obtain the top k frequent words in O(n + k * log(m)) time.</description>
    </item>
    
    <item>
      <title>1985. Find the Kth Largest Integer in the Array</title>
      <link>https://solairerove.github.io/posts/find_the_kth_largest_integer_in_the_array/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/find_the_kth_largest_integer_in_the_array/</guid>
      <description>Use Python&amp;rsquo;s heapq library to obtain the kth largest number in O(n * log(k * m)) time.
# O(n * log(k * m)) time || O(k) space # n is len of nums # m is len of each num # k is k def kth_largest_number_heap(self, nums: List[str], k: int) -&amp;gt; str: heap = [] for num in nums: heapq.heappush(heap, int(num)) if len(heap) &amp;gt; k: heapq.heappop(heap) return str(heap[0]) Quickselect with optimisations.</description>
    </item>
    
    <item>
      <title>215. Kth Largest Element in an Array</title>
      <link>https://solairerove.github.io/posts/kth_largest_element_in_an_array/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/kth_largest_element_in_an_array/</guid>
      <description>Use Python&amp;rsquo;s heapq library to obtain the k largest number in O(nlogk) time.
# O(n * log(k)) time || O(k) space def find_kth_largest_heap(self, nums: List[int], k: int) -&amp;gt; int: return heapq.nlargest(k, nums)[-1] Quickselect with optimisations. Works very slow on leetcode cases. Maybe median of medians will help.
# O(max(n, n^2) time || O(1) space def find_kth_largest_quickselect(self, nums: List[int], k: int) -&amp;gt; int: return quickselect(nums, 0, len(nums) - 1, len(nums) - k) # nums[len(nums) - k] def quickselect(arr, low, high, k): if low == high: return arr[low] lt, gt = partition(arr, low, high, random.</description>
    </item>
    
    <item>
      <title>347. Top K Frequent Elements</title>
      <link>https://solairerove.github.io/posts/top_k_frequent_elements/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/top_k_frequent_elements/</guid>
      <description>Quickselect Explained: Quickselect is a cousin of the quicksort algorithm. The idea behind quickselect is to find the k-th smallest (or largest) element without having to sort the entire list.
Steps of Quickselect: Choose a &amp;lsquo;pivot&amp;rsquo; element from the list and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. Reorder the list so that all elements less than the pivot come before (in no particular order) and all elements greater than the pivot come after it (also in no particular order).</description>
    </item>
    
    <item>
      <title>75. Sort Colors</title>
      <link>https://solairerove.github.io/posts/sort_colors/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/sort_colors/</guid>
      <description># O(n) time || O(1) space def sort_colors(self, nums: List[int]) -&amp;gt; None: lt, i, gt = 0, 0, len(nums) - 1 while i &amp;lt;= gt: if nums[i] == 0: nums[i], nums[lt] = nums[lt], nums[i] i, lt = i + 1, lt + 1 elif nums[i] == 2: nums[i], nums[gt] = nums[gt], nums[i] gt -= 1 else: i += 1 This is the famous &amp;ldquo;Dutch National Flag&amp;rdquo; problem. One common way to solve this problem is using a three-pointer approach.</description>
    </item>
    
    <item>
      <title>252. Meeting Rooms</title>
      <link>https://solairerove.github.io/posts/meeting_rooms/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/meeting_rooms/</guid>
      <description># O(n * log(n)) time || O(n) space def can_attend_meetings(self, intervals: List[List[int]]) -&amp;gt; bool: intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): if intervals[i][0] &amp;lt; intervals[i - 1][1]: return False return True # O(n * log(n)) time || O(n) space def can_attend_meetings_shorter(self, intervals: List[List[int]]) -&amp;gt; bool: intervals.sort(key=lambda x: x[0]) return all(intervals[i][0] &amp;gt;= intervals[i - 1][1] for i in range(1, len(intervals))) To determine whether a person can attend all meetings, we need to ensure that no two meetings overlap.</description>
    </item>
    
    <item>
      <title>253. Meeting Rooms II</title>
      <link>https://solairerove.github.io/posts/meeting_rooms_ii/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/meeting_rooms_ii/</guid>
      <description># O(n * log(n)) time || O(n) space def min_meeting_rooms(self, intervals: List[List[int]]) -&amp;gt; int: start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) res = 0 start, end = 0, 0 while start &amp;lt; len(intervals): if start_times[start] &amp;gt;= end_times[end]: res, end = res - 1, end + 1 res, start = res + 1, start + 1 return res To solve this problem, we can think of the start and end times of the intervals as events.</description>
    </item>
    
    <item>
      <title>435. Non-overlapping Intervals</title>
      <link>https://solairerove.github.io/posts/non_overlapping_intervals/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/non_overlapping_intervals/</guid>
      <description># O(n * log(n)) time || O(log(n)) space def erase_overlap_intervals(self, intervals: List[List[int]]) -&amp;gt; int: intervals.sort(key=lambda x: x[1]) res = 0 end = intervals[0][1] for interval in intervals[1:]: if interval[0] &amp;lt; end: res += 1 else: end = interval[1] return res To solve this problem, we can take a greedy approach. The intuition is that if we choose intervals that end early, it gives us more room for subsequent intervals to fit without overlapping.</description>
    </item>
    
    <item>
      <title>5. Longest Palindromic Substring</title>
      <link>https://solairerove.github.io/posts/longest_palindromic_substring/</link>
      <pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/longest_palindromic_substring/</guid>
      <description># O(n^2) time || O(1) space def longest_palindrome(self, s: str) -&amp;gt; str: def expand(i, j): while i &amp;gt;= 0 and j &amp;lt; len(s) and s[i] == s[j]: i, j = i - 1, j + 1 return s[i + 1: j] return max([expand(i, j) for i in range(len(s)) for j in (i, i + 1)], key=len) This problem can be solved using several methods. A common approach is to expand around the center.</description>
    </item>
    
    <item>
      <title>56. Merge Intervals</title>
      <link>https://solairerove.github.io/posts/merge_intervals/</link>
      <pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/merge_intervals/</guid>
      <description># O(n * log(n)) time || O(n) space def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) res = [intervals[0]] for i in range(1, len(intervals)): if intervals[i][0] &amp;gt; res[-1][1]: res.append(intervals[i]) else: res[-1][1] = max(res[-1][1], intervals[i][1]) return res This is a classic interval problem. The idea is to first sort the intervals based on their start times. After sorting, you can then iterate over the sorted intervals and merge those that overlap.</description>
    </item>
    
    <item>
      <title>20. Valid Parentheses</title>
      <link>https://solairerove.github.io/posts/valid_parentheses/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/valid_parentheses/</guid>
      <description># O(n) time || O(n) space def is_valid(self, s: str) -&amp;gt; bool: close_to_open, stack = {&amp;#34;)&amp;#34;: &amp;#34;(&amp;#34;, &amp;#34;]&amp;#34;: &amp;#34;[&amp;#34;, &amp;#34;}&amp;#34;: &amp;#34;{&amp;#34;}, [] for c in s: if c not in close_to_open: stack.append(c) elif stack: if stack.pop() != close_to_open[c]: return False else: return False return not stack Initialize an empty stack. Traverse the string character by character. For each character: If it&amp;rsquo;s an open bracket (&amp;rsquo;(&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, or &amp;lsquo;[&amp;rsquo;), push it onto the stack.</description>
    </item>
    
    <item>
      <title>200. Number of Islands</title>
      <link>https://solairerove.github.io/posts/number_of_islands/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/number_of_islands/</guid>
      <description># O(n * m) time || O(n * m) space def num_islands_dfs(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) def dfs(i, j): if 0 &amp;lt;= i &amp;lt; n and 0 &amp;lt;= j &amp;lt; m and grid[i][j] == &amp;#34;1&amp;#34;: grid[i][j] = &amp;#34;0&amp;#34; dfs(i - 1, j) dfs(i + 1, j) dfs(i, j - 1) dfs(i, j + 1) res = 0 for i in range(n): for j in range(m): if grid[i][j] == &amp;#34;1&amp;#34;: res += 1 dfs(i, j) return res # O(n * m) time || O(n * m) space def num_islands_dfs_shorter(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) def dfs(i, j): if 0 &amp;lt;= i &amp;lt; n and 0 &amp;lt;= j &amp;lt; m and grid[i][j] == &amp;#34;1&amp;#34;: grid[i][j] = &amp;#34;0&amp;#34; list(map(dfs, [i - 1, i + 1, i, i], [j, j, j - 1, j + 1])) res = 0 for i in range(n): for j in range(m): if grid[i][j] == &amp;#34;1&amp;#34;: res += 1 dfs(i, j) return res # O(n * m) time || O(min(n, m)) space def num_islands_bfs(self, grid: List[List[str]]) -&amp;gt; int: n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(i, j): dq = collections.</description>
    </item>
    
    <item>
      <title>301. Remove Invalid Parentheses</title>
      <link>https://solairerove.github.io/posts/remove_invalid_parentheses/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/remove_invalid_parentheses/</guid>
      <description># O(n * 2 ^ n) time || O(2 ^ n) space def remove_invalid_parentheses(self, s: str) -&amp;gt; List[str]: def is_valid(string): cnt = 0 for c in string: if c == &amp;#39;(&amp;#39;: cnt += 1 elif c == &amp;#39;)&amp;#39;: cnt -= 1 if cnt &amp;lt; 0: return False return cnt == 0 res = [] dq, visited, found = collections.deque([s]), {str}, False while dq: curr_str = dq.popleft() if curr_str not in visited: visited.</description>
    </item>
    
    <item>
      <title>977. Squares of a Sorted Array</title>
      <link>https://solairerove.github.io/posts/squares_of_a_sorted_array/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/squares_of_a_sorted_array/</guid>
      <description># O(n) time || O(1) space def sorted_squares(self, nums: List[int]) -&amp;gt; List[int]: res = [0] * len(nums) pos = len(nums) - 1 low, high = 0, len(nums) - 1 while low &amp;lt;= high: if abs(nums[low]) &amp;gt; abs(nums[high]): res[pos] = nums[low] ** 2 low += 1 else: res[pos] = nums[high] ** 2 high -= 1 pos -= 1 return res Given that the array is sorted in non-decreasing order, the negative numbers will be on the left side and the positive numbers on the right.</description>
    </item>
    
    <item>
      <title>844. Backspace String Compare</title>
      <link>https://solairerove.github.io/posts/backspace_string_compare/</link>
      <pubDate>Thu, 19 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/backspace_string_compare/</guid>
      <description># O(n + m) time || O(1) space def backspace_compare_two_pointers(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): skip = 0 for c in reversed(to_trim): if c == &amp;#39;#&amp;#39;: skip += 1 elif skip: skip -= 1 else: yield c return all(a == b for a, b in itertools.zip_longest(trim(s), trim(t))) # O(n + m) time || O(n + m) space def backspace_compare_stack(self, s: str, t: str) -&amp;gt; bool: def trim(to_trim): stack = [] for c in to_trim: if c !</description>
    </item>
    
    <item>
      <title>11. Container With Most Water</title>
      <link>https://solairerove.github.io/posts/container_with_most_water/</link>
      <pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://solairerove.github.io/posts/container_with_most_water/</guid>
      <description># O(n) time || O(1) space def max_area(self, height: List[int]) -&amp;gt; int: res, low, high = 0, 0, len(height) - 1 while low &amp;lt; high: res = max(res, (high - low) * (min(height[low], height[high]))) if height[low] &amp;lt;= height[high]: low += 1 else: high -= 1 return res This problem is known as the &amp;ldquo;Container With Most Water&amp;rdquo; and is a well-known example of a two-pointer technique.
Here&amp;rsquo;s the strategy to solve it:</description>
    </item>
    
  </channel>
</rss>
