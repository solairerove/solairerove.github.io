<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sorting on Headstone lamp - It&#39;s always has been</title>
    <link>https://solairerove.github.io/categories/sorting/</link>
    <description>Recent content in sorting on Headstone lamp - It&#39;s always has been</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 06 Apr 2021 20:10:04 +0300</lastBuildDate><atom:link href="https://solairerove.github.io/categories/sorting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Quick Sort 3 Way</title>
      <link>https://solairerove.github.io/post/quick-sort-3-way/</link>
      <pubDate>Tue, 06 Apr 2021 20:10:04 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/quick-sort-3-way/</guid>
      <description>Вариант быстрой сортировки с трехчастным разбиением для массивов с низкой энтропией.
a[low]..a[lt - 1] &amp;lt;= a[j] &amp;lt;= a[gt + 1]..a[high] a[lt - 1] = a[j] = a[gt + 1]
princeton quicksort 3 way
quick sort 3 way
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // O(nlog(n)) time | O(log(n)) space fun quickSort(arr: MutableList&amp;lt;Int&amp;gt;, low: Int = 0, high: Int = arr.</description>
    </item>
    
    <item>
      <title>Quick Sort</title>
      <link>https://solairerove.github.io/post/quick-sort/</link>
      <pubDate>Mon, 05 Apr 2021 18:10:55 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/quick-sort/</guid>
      <description>Классический эффективный алгоритм сортировки divide and conquer.
Разбиваем массив и независимо сортируем подмассивы. \
a[low]..a[j - 1] &amp;lt;= a[j] &amp;lt;= a[j + 1]..a[high]
princeton quicksort
quick sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // O(nlog(n)) time | O(log(n)) space fun quickSort(arr: MutableList&amp;lt;Int&amp;gt;, low: Int = 0, high: Int = arr.</description>
    </item>
    
    <item>
      <title>Inversions</title>
      <link>https://solairerove.github.io/post/inversions/</link>
      <pubDate>Wed, 31 Mar 2021 23:10:38 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/inversions/</guid>
      <description>Вытекающая задача из сортировки слиянием.
Смысл решения в том, что мы точно знаем, что i меньше j,
поэтому когда j элемент меньше i, то мы получаем инверсию. \ И раз он меньше, то он будет меньше и всех остальных элементов в части i.
Именно поэтому mid + 1 - i -&amp;gt; просто длина подмассива.
3.2 Подсчет инверсий
inversions
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  // O(nlog(n)) time | O(n) space fun count(arr: MutableList&amp;lt;Int&amp;gt;): Long { val n = arr.</description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://solairerove.github.io/post/merge-sort/</link>
      <pubDate>Fri, 26 Mar 2021 17:28:02 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/merge-sort/</guid>
      <description>Классический эффективный алгоритм сортировки divide and conquer.
Разделяем массив на подмассивы до подмассивов размером 1 и
собираем их в отсортированные подмассивы.
Почему O(nlog(n)).
Потому что у нас всего nlog(n) операций, которые сами по себе O(n).
princeton mergesort
merge sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // O(nlog(n)) time | O(n) space fun mergeSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.</description>
    </item>
    
    <item>
      <title>Heap Sort</title>
      <link>https://solairerove.github.io/post/heap-sort/</link>
      <pubDate>Tue, 09 Mar 2021 17:45:39 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/heap-sort/</guid>
      <description>build heap from array and n time get min element. (naive heap sort)
heap sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // O(nlogn) time | O(1) space fun heapSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (k in n / 2 downTo 1) { sink(arr, k, n) } var k = n while (k &amp;gt; 1) { swap(arr, 1, k--) sink(arr, 1, k) } } fun sink(arr: MutableList&amp;lt;Int&amp;gt;, k: Int, n: Int) { var idx = k while (2 * idx &amp;lt;= n) { var j = 2 * idx if (j &amp;lt; n &amp;amp;&amp;amp; less(arr, j, j + 1)) j++ if (!</description>
    </item>
    
    <item>
      <title>Insertion Sort</title>
      <link>https://solairerove.github.io/post/insertion-sort/</link>
      <pubDate>Mon, 01 Mar 2021 16:55:11 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/insertion-sort/</guid>
      <description>Один из алгоритмов сортировки. На каждом шаге вставляет на свое место элемент в отсортированный подмассив.
insertion sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // O(n^2) time | O(1) space fun insertionSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 1 until n) { for (j in i downTo 0) { if (j &amp;gt; 0 &amp;amp;&amp;amp; arr[j] &amp;lt; arr[j - 1]) { swap(arr, j, j - 1) } } } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp }   </description>
    </item>
    
    <item>
      <title>Bubble Sort</title>
      <link>https://solairerove.github.io/post/bubble-sort/</link>
      <pubDate>Mon, 01 Mar 2021 14:33:33 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/bubble-sort/</guid>
      <description>Один из не эффективных алгоритмов сортировки, кроме случая, когда коллекция обратно отсортирована. На каждом шаге проталкивает самый большой элемент в конец списка.
bubble sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // O(n^2) time | O(1) space fun bubbleSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 0 until n) { for (j in 0 until (n - i - 1)) { if (arr[j + 1] &amp;lt; arr[j]) { swap(arr, j + 1, j) } } } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp }   </description>
    </item>
    
    <item>
      <title>Selection Sort</title>
      <link>https://solairerove.github.io/post/selection-sort/</link>
      <pubDate>Mon, 01 Mar 2021 13:40:33 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/selection-sort/</guid>
      <description>Один из не эффективных алгоритмов сортировки. На каждом шаге находит минимальный элемент и меняет местами с текущим.
selection sort
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // O(n^2) time | O(1) space fun selectionSort(arr: MutableList&amp;lt;Int&amp;gt;) { val n = arr.size for (i in 0 until n) { var min = i for (j in (i + 1) until n) { if (arr[j] &amp;lt; arr[min]) { min = j } } swap(arr, i, min) } } fun swap(arr: MutableList&amp;lt;Int&amp;gt;, i: Int, j: Int) { val temp = arr[i] arr[i] = arr[j] arr[j] = temp }   </description>
    </item>
    
  </channel>
</rss>
