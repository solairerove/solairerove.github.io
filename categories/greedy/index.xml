<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>greedy on Even - A super concise theme for Hugo</title>
    <link>https://solairerove.github.io/categories/greedy/</link>
    <description>Recent content in greedy on Even - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 08 Mar 2021 17:27:29 +0300</lastBuildDate><atom:link href="https://solairerove.github.io/categories/greedy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Minimum Waiting Time</title>
      <link>https://solairerove.github.io/post/minimum-waiting-time/</link>
      <pubDate>Mon, 08 Mar 2021 17:27:29 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/minimum-waiting-time/</guid>
      <description>Given non-empty array of positive int, that define time to execute.
Only one query can be executed at time, but in any order.
Get minimal waiting time to execute all queries.
Solid step is ascending sort.
9 6 5 2 3 1 -&amp;gt; 1 2 3 5 6 9 -&amp;gt; 0 + 1 + (1 + 2) + (1 + 2 + 3) + (1 + 2 + 3 + 5) + (1 + 2 + 3 + 5 + 6) = 38</description>
    </item>
    
    <item>
      <title>Huffman Decode</title>
      <link>https://solairerove.github.io/post/huffman-decode/</link>
      <pubDate>Sun, 07 Mar 2021 18:25:44 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/huffman-decode/</guid>
      <description>Формулировка задачи
huffman decode
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // abacabad fun main() { val dictionary = mapOf( Pair(&amp;#34;0&amp;#34;, &amp;#34;a&amp;#34;), Pair(&amp;#34;10&amp;#34;, &amp;#34;b&amp;#34;), Pair(&amp;#34;110&amp;#34;, &amp;#34;c&amp;#34;), Pair(&amp;#34;111&amp;#34;, &amp;#34;d&amp;#34;) ) val s = &amp;#34;01001100100111&amp;#34; val stringBuilder = StringBuilder() var i = 0 while (i &amp;lt; s.length) { var isCodeFound = false var code = s[i].</description>
    </item>
    
    <item>
      <title>Naive Huffman Encode</title>
      <link>https://solairerove.github.io/post/naive-huffman-encode/</link>
      <pubDate>Sun, 07 Mar 2021 15:55:23 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/naive-huffman-encode/</guid>
      <description>Формулировка задачи
naive huffman encode
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  /** * abacabad * 4 14 * a: 0 * b: 10 * c: 110 * d: 111 * 01001100100111 */ fun main() { val s = &amp;#34;abacabad&amp;#34; val letterToFreq = getLetterToFrequency(s = s) val letterWeightStack = getLetterWeightStack(letterToFreq = letterToFreq) val huffmanResult = huffman(letterWeightStack = letterWeightStack) val dictionary = getDictionary(huffmanResult = huffmanResult) val encodedString = encodeString(stringToEncode = s, dictionary = dictionary) println(&amp;#34;${dictionary.</description>
    </item>
    
    <item>
      <title>Number Partition</title>
      <link>https://solairerove.github.io/post/number-partition/</link>
      <pubDate>Thu, 04 Mar 2021 18:55:57 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/number-partition/</guid>
      <description>Формулировка задачи
number partition
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fun main() { var n = 6 val res = mutableListOf&amp;lt;Int&amp;gt;() for (i in 1..n) { if (n - i &amp;gt;= i + 1) { res.add(i) } else { res.add(n) break } n -= i } print(&amp;#34;${res.size}\n&amp;#34;) res.forEach { print(&amp;#34;$it&amp;#34;) } }   </description>
    </item>
    
    <item>
      <title>Knapsack Problem</title>
      <link>https://solairerove.github.io/post/knapsack-problem/</link>
      <pubDate>Thu, 04 Mar 2021 17:58:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/knapsack-problem/</guid>
      <description>Формулировка задачи
knapsack problem
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import java.text.DecimalFormat fun main() { var backPackSize = 50 val items = mutableListOf( Item(worth = 60, volume = 20, worthPerVolume = (60 / 20).toDouble()), Item(worth = 100, volume = 50, worthPerVolume = (100 / 50).</description>
    </item>
    
    <item>
      <title>Segments Covering by Unit</title>
      <link>https://solairerove.github.io/post/segments-covering-by-unit/</link>
      <pubDate>Thu, 04 Mar 2021 13:00:03 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/segments-covering-by-unit/</guid>
      <description>Даны отрезки на прямой. Найти такие точки, которые лежат на всех заданных отрезках. Найденное множество должно быть минимальным по размеру.
Берем все концы отрезков (как левые, так и правые) и сортируем их. Для каждой точки сохраним номер отрезка. Также каким концом его она является (левым или правым). Учтем, что если есть несколько точек с одной координатой, то сначала будут идти левые концы, потом правые.
Заведём коллекцию, в которой будут храниться номера отрезков, рассматриваемых в данный момент.</description>
    </item>
    
  </channel>
</rss>
