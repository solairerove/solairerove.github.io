<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>search on Headstone lamp - It&#39;s always has been</title>
    <link>https://solairerove.github.io/categories/search/</link>
    <description>Recent content in search on Headstone lamp - It&#39;s always has been</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 08 Apr 2021 22:24:47 +0300</lastBuildDate><atom:link href="https://solairerove.github.io/categories/search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bisect left</title>
      <link>https://solairerove.github.io/post/bisect_left/</link>
      <pubDate>Thu, 08 Apr 2021 22:24:47 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/bisect_left/</guid>
      <description>binary select left
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // O(log(n)) time | O(1) space fun biSectLeft(arr: List&amp;lt;Int&amp;gt;, target: Int, lo: Int = 0, hi: Int = arr.size): Int { val n = arr.size if (n == 0) return 0 var low = lo var high = hi if (target &amp;lt; arr[low]) return low if (target &amp;gt; arr[high - 1]) return high while (true) { if (low + 1 == high) { return if (target == arr[low]) low else (low + 1) } val mid = low + (high - low) / 2 when { target &amp;lt;= arr[mid] -&amp;gt; high = mid else -&amp;gt; low = mid } } }   </description>
    </item>
    
    <item>
      <title>Bisect right</title>
      <link>https://solairerove.github.io/post/bisect_right/</link>
      <pubDate>Thu, 08 Apr 2021 22:24:43 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/bisect_right/</guid>
      <description>binary select right
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // O(log(n)) time | O(1) space fun biSectRight(arr: List&amp;lt;Int&amp;gt;, target: Int, lo: Int = 0, hi: Int = arr.size): Int { val n = arr.size if (n == 0) return 0 var low = lo var high = hi if (target &amp;lt; arr[low]) return low if (target &amp;gt; arr[high - 1]) return high while (true) { if (low + 1 == high) { return low + 1 } val mid = low + (high - low) / 2 when { target &amp;lt; arr[mid] -&amp;gt; high = mid else -&amp;gt; low = mid } } }   </description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://solairerove.github.io/post/binary-search/</link>
      <pubDate>Thu, 25 Feb 2021 17:32:26 +0300</pubDate>
      
      <guid>https://solairerove.github.io/post/binary-search/</guid>
      <description>Бинарный поиск - алгоритм, на вход которого подается отсортированный список элементов. Если искомый элемент присутствует, то бинарный поиск возвращает его позицию.
Предположим, что вы загадали число от 1 до 100. При каждой попытке угадать я буду давать один из трех ответов: много, мало и угадал. Можно перебирать все вариант подряд: 1, 2, 3, 4. А можно исключить сразу половину чисел на каждом шаге: 50, 75, 63.
binary search
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // O(log(n)) time | O(1) space private fun binarySearch(items: List&amp;lt;Int&amp;gt;, item: Int): Int { // храним границы части списка, в которой выполняется поиск  var low = 0 var high = items.</description>
    </item>
    
  </channel>
</rss>
